<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TERL</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0c0c0c; color: #e0e0e0; font-family: 'Segoe UI', 'Roboto', sans-serif; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; display: flex; flex-direction: column; background: #000; }
        #top-ui-bar { height: 50px; background: #1a1a1a; display: flex; align-items: center; justify-content: space-between; padding: 0 20px; border-bottom: 1px solid #333; z-index: 10; flex-shrink: 0; }
        #top-ui-bar .ui-group { display: flex; align-items: center; gap: 10px; font-size: 0.9em; }
        #top-ui-bar .ui-label { color: #aaa; margin-right: 5px; }
        #top-ui-year, #top-ui-tension { display: inline-block; min-width: 3.5em; text-align: right; font-variant-numeric: tabular-nums; font-family: monospace; }
        #top-ui-tension { min-width: 4em; }
        #canvas-wrapper { flex: 1; position: relative; overflow: hidden; cursor: crosshair; }
        canvas { display: block; image-rendering: pixelated; }
        #sidebar { width: 320px; background: #1a1a1a; padding: 20px; overflow-y: auto; box-shadow: -2px 0 10px rgba(0,0,0,0.8); display: flex; flex-direction: column; gap: 15px; border-left: 1px solid #333; }

        @media (max-width: 768px) {
            #container { flex-direction: column; }
            #sidebar { width: 100%; height: 40vh; border-left: none; border-top: 1px solid #333; box-sizing: border-box; }
            #canvas-container { height: 60vh; }
            #top-ui-bar { padding: 0 10px; gap: 5px; }
            #top-ui-bar .ui-group { gap: 5px; }
            .ui-label { font-size: 0.8em; margin-right: 2px; }
            #top-ui-year, #top-ui-tension { font-size: 0.9em; min-width: 3em; }
            .ui-label-speed { display: none; }
            #simSpeed { width: 60px !important; }
            #btn-pause { padding: 4px 8px !important; font-size: 0.8em; }
        }
        
        h1, h2 { margin: 0 0 10px 0; color: #ccc; text-transform: uppercase; letter-spacing: 2px; font-weight: 300; }
        h1 { font-size: 1.4em; border-bottom: 1px solid #555; padding-bottom: 8px; color: #4db8ff; }
        .panel { background: #222; padding: 15px; border-radius: 0; border: 1px solid #444; margin-bottom: 10px; }
        button { background: #34495e; border: 1px solid #5d6d7e; padding: 10px; color: #ecf0f1; font-weight: bold; cursor: pointer; width: 100%; margin-top: 5px; transition: 0.2s; }
        button:hover { background: #4db8ff; color: #000; }
        button:disabled { background: #666; cursor: not-allowed; }
        
        .stat-row { display: flex; justify-content: space-between; font-size: 0.9em; margin-bottom: 3px; }
        .bar-bg { background: #222; height: 6px; border-radius: 3px; overflow: hidden; margin-bottom: 8px; }
        .bar-fill { height: 100%; background: #ccc; }
        
        #log { font-size: 0.8em; height: 150px; overflow-y: auto; background: #111; padding: 5px; font-family: monospace; border: 1px solid #555; }
        .log-war { color: #ff6b6b; }
        .log-peace { color: #51cf66; }
        .log-info { color: #aaa; }
        
        /* Tooltip style overlay */
        #hover-info { position: absolute; background: rgba(0,0,0,0.8); padding: 5px; pointer-events: none; border-radius: 4px; display: none; font-size: 0.8em; z-index: 10; border: 1px solid #666; }
        
        /* Ranking Table */
        .ranking-table { width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 0.9em; }
        .ranking-table th, .ranking-table td { padding: 5px 8px; text-align: left; border-bottom: 1px solid #444; }
        .ranking-table th { background: #333; color: #ccc; }
        .ranking-table tr:nth-child(even) { background: #2a2a2a; }
        .ranking-section-title { margin: 15px 0 5px 0; color: #4db8ff; border-bottom: 1px solid #555; padding-bottom: 2px; }
        .rank-bar-container { background: #444; width: 100%; height: 10px; border-radius: 5px; overflow: hidden; }
        .rank-bar { height: 100%; transition: width 0.5s; }
    </style>
<link rel="apple-touch-icon" href="icon192x192.png">
<link rel="icon" href="icon192x192.png">
<link rel="manifest" href="manifest.json">
<script>
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js');
}
</script>
</head>
<body>

<div id="history-modal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:#222; border:1px solid #444; padding:20px; z-index:1000; width:300px; max-height:80vh; overflow-y:auto; box-shadow: 0 0 20px rgba(0,0,0,0.8);">
    <h2 style="margin-top:0; border-bottom:1px solid #555; padding-bottom:5px;">å›½å®¶ç³»è­œ</h2>
    <div id="history-list" style="font-size:0.9em; line-height:1.4;"></div>
    <button onclick="document.getElementById('history-modal').style.display='none'" style="margin-top:15px;">é–‰ã˜ã‚‹</button>
</div>

<div id="ranking-modal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:#222; border:1px solid #444; padding:20px; z-index:1000; width:90%; max-width:800px; max-height:80vh; overflow-y:auto; box-shadow: 0 0 20px rgba(0,0,0,0.8);">
    <h2 style="margin-top:0; border-bottom:1px solid #555; padding-bottom:5px;">å›½åŠ›ãƒ©ãƒ³ã‚­ãƒ³ã‚°</h2>
    <div id="ranking-content"></div>
    <button onclick="document.getElementById('ranking-modal').style.display='none'" style="margin-top:15px; width:100%;">é–‰ã˜ã‚‹</button>
</div>

<div id="rulebook-modal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:#222; border:1px solid #444; padding:20px; z-index:1000; width:90%; max-width:600px; max-height:80vh; overflow-y:auto; box-shadow: 0 0 20px rgba(0,0,0,0.8); font-size: 0.9em; line-height: 1.6; box-sizing: border-box;">
    <h2 style="margin-top:0; border-bottom:1px solid #555; padding-bottom:5px;">ãƒ«ãƒ¼ãƒ«ãƒ–ãƒƒã‚¯ & ã‚·ã‚¹ãƒ†ãƒ è©³ç´°</h2>
    
    <h3>åŸºæœ¬æ“ä½œ</h3>
    <p>
        <strong>ãƒãƒƒãƒ—ãƒ‡ã‚¶ã‚¤ãƒ³:</strong> å·¦ã‚¯ãƒªãƒƒã‚¯/ã‚¿ãƒƒãƒã§åœ°å½¢ã‚’æç”»ã€å³ã‚¯ãƒªãƒƒã‚¯ã§æ¶ˆå»ã€‚ã€Œå¡—ã‚Šã¤ã¶ã—ãƒ¢ãƒ¼ãƒ‰ã€ã§é ˜åŸŸã‚’ä¸€æ‹¬å¤‰æ›´å¯èƒ½ã§ã™ã€‚<br>
        <strong>ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³:</strong> ã€Œä¸–ç•Œã‚’ç”Ÿæˆã€ã§æ­´å²ãŒå§‹ã¾ã‚Šã¾ã™ã€‚é€Ÿåº¦ãƒãƒ¼ã§é€²è¡Œé€Ÿåº¦ã‚’èª¿æ•´ã€ä¸€æ™‚åœæ­¢ã‚‚å¯èƒ½ã§ã™ã€‚
    </p>

    <h3>å›½å®¶ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</h3>
    <p>
        <strong>å®‰å®šåº¦ (Stability):</strong> å›½å®¶ã®å­˜ç¶šã«é–¢ã‚ã‚‹æœ€é‡è¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€‚ä½ã„ã¨å†…æˆ¦ã‚„æ”¿å¤‰ãŒç™ºç”Ÿã—ã¾ã™ã€‚æˆ¦äº‰ã‚„ã‚¤ãƒ™ãƒ³ãƒˆã§ä½ä¸‹ã—ã¾ã™ã€‚<br>
        <strong>æŠ€è¡“ (Technology):</strong> 5æ®µéšï¼ˆåŸå§‹çš„ã€œæœªæ¥çš„ï¼‰ã€‚æŠ€è¡“ãƒ¬ãƒ™ãƒ«ãŒé«˜ã„ã»ã©ã€äººå£æ”¯æŒåŠ›ã€GDPæˆé•·ç‡ã€è»äº‹åŠ›ãŒå‘ä¸Šã—ã¾ã™ã€‚<br>
        <strong>GDP & ç”£æ¥­:</strong> çµŒæ¸ˆåŠ›ã€‚è»äº‹è²»ã®æºæ³‰ã¨ãªã‚Šã¾ã™ã€‚<br>
        <strong>æ”¿æ²»ä½“åˆ¶:</strong> æ°‘ä¸»ä¸»ç¾©ã€æ¨©å¨ä¸»ç¾©ã€å…¨ä½“ä¸»ç¾©ã®3å¤§åŒºåˆ†ã«åŠ ãˆã€è©³ç´°ãªçµ±æ²»å½¢æ…‹ï¼ˆè­°é™¢å†…é–£åˆ¶ã€è»äº‹æ”¿æ¨©ãªã©ï¼‰ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚
    </p>

    <h3>è»äº‹ã¨æˆ¦äº‰</h3>
    <p>
        <strong>é™¸è»:</strong> äººå£ã¨GDPã«åŸºã¥ã„ã¦å¾´å…µãƒ»ç¶­æŒã•ã‚Œã¾ã™ã€‚<br>
        <strong>æµ·è»:</strong> æŠ€è¡“ãƒ¬ãƒ™ãƒ«2ä»¥ä¸Šã€ã‹ã¤æ²¿å²¸éƒ½å¸‚ã‚’æŒã¤å›½å®¶ã®ã¿ãŒå»ºé€ å¯èƒ½ã§ã™ã€‚<br>
        <strong>ä¸Šé™¸ä½œæˆ¦:</strong> <strong>æŠ€è¡“ãƒ¬ãƒ™ãƒ«3ï¼ˆç¾ä»£çš„ï¼‰ä»¥ä¸Š</strong>ã‹ã¤<strong>è»è‰¦20éš»ä»¥ä¸Š</strong>ã‚’ä¿æœ‰ã™ã‚‹å›½å®¶ã®ã¿ã€æµ·ã‚’è¶ŠãˆãŸæ•µå›½ã¸ã®ä¸Šé™¸ä¾µæ”»ãŒå¯èƒ½ã§ã™ã€‚<br>
        <strong>æˆ¦äº‰:</strong> éš£æ¥å›½ã¨ã®é–¢ä¿‚æ‚ªåŒ–ã‚„é‡å¿ƒã«ã‚ˆã£ã¦ç™ºç”Ÿã—ã¾ã™ã€‚
    </p>

    <h3>å†…æˆ¦ã¨ç‹¬ç«‹</h3>
    <p>
        <strong>éƒ½å¸‚åä¹±:</strong> é¦–éƒ½ã‹ã‚‰é ã„éƒ½å¸‚ã€ç‰¹ã«<strong>æµ·ã‚’éš”ã¦ãŸåˆ¥å¤§é™¸ã«ã‚ã‚‹éƒ½å¸‚</strong>ã¯ä¸æº€ã‚’æŒã¡ã‚„ã™ãï¼ˆ+25ãƒšãƒŠãƒ«ãƒ†ã‚£ï¼‰ã€åä¹±ã‚’èµ·ã“ã™ãƒªã‚¹ã‚¯ãŒé«˜ã¾ã‚Šã¾ã™ã€‚<br>
        <strong>å‚€å„¡å›½ã®ç‹¬ç«‹:</strong> å®—ä¸»å›½ãŒä¸å®‰å®šã«ãªã‚‹ã¨ç‹¬ç«‹ã‚’ç”»ç­–ã—ã¾ã™ã€‚<strong>æµ·ã‚’éš”ã¦ã¦ã„ã‚‹å ´åˆ</strong>ã€ç‹¬ç«‹ç¢ºç‡ã¯4å€ã«ãªã‚Šã€å¿…è¦ãªå®—ä¸»å›½ã®ä¸å®‰å®šåº¦æ¡ä»¶ã‚‚ç·©å’Œã•ã‚Œã¾ã™ã€‚<br>
        <strong>åä¹±è»:</strong> æˆåŠŸã™ã‚Œã°æ­£çµ±æ”¿åºœã¨ã—ã¦èªã‚ã‚‰ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
    </p>

    <h3>è¬›å’Œæ¡ç´„ã®ç¨®é¡</h3>
    <ul>
        <li><strong>ç™½ç´™è¬›å’Œ:</strong> å›½å¢ƒå¤‰æ›´ãªã—ã§åœæˆ¦ã€‚</li>
        <li><strong>é ˜åœŸå‰²è­²:</strong> ä¸€éƒ¨ã®éƒ½å¸‚ã‚„åœŸåœ°ã‚’å‹è€…ã«å‰²è­²ã€‚</li>
        <li><strong>å›½å¢ƒåœ°å¸¯ä½µåˆ:</strong> æ¥ã—ã¦ã„ã‚‹å›½å¢ƒåœ°å¸¯ã‚’ã”ã£ãã‚Šå¥ªã†ã€‚</li>
        <li><strong>å‚€å„¡åŒ–:</strong> æ•—æˆ¦å›½ã‚’å¾“å±ã•ã›ã€ä¸»æ¨©ã‚’å¥ªã†ã€‚</li>
    </ul>

    <h3>è¦‡æ¨©å›½ã®ç§©åºç¶­æŒ (Pax Hegemonica)</h3>
    <p>
        ä¸–ç•Œã®<strong>é™¸åœ°é¢ç©ã®2/3ä»¥ä¸Š</strong>ã‚’æ”¯é…ã™ã‚‹è¶…å¤§å›½ãŒç¾ã‚Œã‚‹ã¨ã€ãã®å›½ã¯ã€Œè¦‡æ¨©å›½ã€ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚<br>
        è¦‡æ¨©å›½ã¯è‡ªã‚‰ä¾µç•¥æˆ¦äº‰ã‚’è¡Œã‚ãªããªã‚Šã€ä»£ã‚ã‚Šã«ä»–å›½ã®ç´›äº‰ã«ä»‹å…¥ã—ã¦å¼·åˆ¶çš„ã«åœæˆ¦ã•ã›ã‚‹ã€Œç§©åºç¶­æŒã€è¡Œå‹•ã‚’ã¨ã‚Šã¾ã™ã€‚<br>
        ãŸã ã—ã€é ˜åœŸãŒ2/3ã‚’ä¸‹å›ã‚‹ã¨å†ã³è¦‡æ¨©äº‰ã„ã«æˆ»ã‚Šã¾ã™ã€‚
    </p>

    <button onclick="document.getElementById('rulebook-modal').style.display='none'" style="margin-top:15px; width: 100%;">é–‰ã˜ã‚‹</button>
</div>

<div id="container">
    <div id="canvas-container">
        <div id="top-ui-bar">
            <div class="ui-group">
                <span class="ui-label">å¹´:</span> <span id="top-ui-year" style="font-weight:bold; color:#fff;">1</span>
                <span class="ui-label" style="margin-left: 10px;">ç·Šå¼µåº¦:</span> <span id="top-ui-tension" style="font-weight:bold; color:#4db8ff;">0.0%</span>
            </div>
            <div class="ui-group">
                <span class="ui-label-speed" style="font-size:0.9em;">é€Ÿåº¦:</span>
                <input type="range" id="simSpeed" min="1" max="10" value="5" style="width:100px;">
                <button id="btn-pause" style="width: auto; padding: 5px 10px; margin-top: 0; margin-left: 5px;">åœæ­¢/å†é–‹</button>
            </div>
        </div>
        <div id="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
            <div id="hover-info"></div>
        </div>
    </div>
    
    <div id="sidebar">
        <h1>TERL-ãƒ†ãƒªãƒ« ä¸–ç•Œã‚·ãƒ¥ãƒŸãƒ¬ãƒ¼ã‚¿ãƒ¼</h1>
        
        <div id="menu-panel" class="panel">
            <h2>1. ãƒãƒƒãƒ—ãƒ‡ã‚¶ã‚¤ãƒ³</h2>
            <p>å·¦ã‚¯ãƒªãƒƒã‚¯/ã‚¿ãƒƒãƒ: æç”» (å³ã‚¯ãƒªãƒƒã‚¯ã§æ¶ˆå»)</p>
            <button id="btn-brush" style="margin-bottom:10px;">ãƒ–ãƒ©ã‚·: é™¸åœ°</button>
            <div>
                ã‚µã‚¤ã‚º: <select id="mapSize">
                    <option value="64">å° (64x64)</option>
                    <option value="128" selected>ä¸­ (128x128)</option>
                    <option value="256">å¤§ (256x256)</option>
                </select>
            </div>
            <button id="btn-fill" style="margin-bottom:10px;">å¡—ã‚Šã¤ã¶ã—ãƒ¢ãƒ¼ãƒ‰: ã‚ªãƒ•</button>
            <button id="btn-generate">ä¸–ç•Œã‚’ç”Ÿæˆ (ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹)</button>
        </div>

        <div id="sim-panel" class="panel" style="display:none;">
            <h2>2. ä¸–ç•Œæƒ…å‹¢</h2>
            <div class="stat-row"><span>å¹´:</span> <span id="info-year">1</span></div>
            <div class="stat-row"><span>ç·äººå£:</span> <span id="info-pop">0</span></div>
            <div class="stat-row"><span>ç·Šå¼µåº¦:</span> <span id="info-tension">0%</span></div>
            <div class="stat-row"><span>è¦‡æ¨©å›½:</span> <span id="info-hegemon" style="font-weight:bold;">ãªã—</span></div>
            <button id="btn-ranking" style="margin-bottom:10px; background:#6c5ce7; border-color:#8e44ad;">ğŸ“Š å›½åŠ›ãƒ©ãƒ³ã‚­ãƒ³ã‚°</button>
            <button id="btn-map-mode" style="margin-bottom:10px;">åœ°å›³ãƒ¢ãƒ¼ãƒ‰: æ”¿æ²»</button>
        </div>

        <div id="nation-panel" class="panel" style="display:none;">
            <h2 id="n-name">å›½å®¶å</h2>
            <div class="stat-row"><span>æŒ‡å°è€…:</span> <span id="n-leader"></span></div>
            <div class="stat-row"><span>çµŒæ¸ˆæ€æƒ³:</span> <span id="n-eco"></span></div>
            <div class="stat-row"><span>æ”¿æ²»ä½“åˆ¶(å¤§æ ):</span> <span id="n-sys-broad"></span></div>
            <div class="stat-row"><span>æ”¿æ²»ä½“åˆ¶(è©³ç´°):</span> <span id="n-gov"></span></div>
            <div class="stat-row"><span>å›½å®¶ä½“åˆ¶:</span> <span id="n-struct"></span></div>
            <div class="stat-row"><span>ä¸»æ¨©è€…:</span> <span id="n-sov"></span></div>
            <div class="stat-row"><span>å®—æ•™:</span> <span id="n-religion"></span></div>
            <div class="stat-row"><span>æŠ€è¡“:</span> <span id="n-tech"></span></div>
            <div class="stat-row"><span>å®‰å®šåº¦:</span> <span id="n-stability"></span></div>
            <div class="stat-row"><span>çµ±æ²»å®‰å®šåº¦:</span> <span id="n-governance"></span></div>
            
            <hr style="border-color:#555">
            
            <div class="stat-row"><span>å›½å†…ç·ç”Ÿç”£(GDP):</span> <span id="n-gdp"></span></div>
            <div class="bar-bg"><div id="bar-gdp" class="bar-fill" style="width:0; background:#f1c40f"></div></div>
            
            <div class="stat-row"><span>äººå£:</span> <span id="n-pop"></span></div>
            <div class="bar-bg"><div id="bar-pop" class="bar-fill" style="width:0; background:#2ecc71"></div></div>
            
            <div class="stat-row"><span>è»äº‹åŠ›:</span> <span id="n-mil"></span></div>
            <div class="bar-bg"><div id="bar-mil" class="bar-fill" style="width:0; background:#e74c3c"></div></div>

            <div class="stat-row"><span>å·¥æ¥­åŠ›:</span> <span id="n-ind"></span></div>
            <div class="stat-row"><span>æˆ¦è»Šæ•°:</span> <span id="n-tanks"></span></div>
            <div class="stat-row"><span>æµ·è»åŠ›:</span> <span id="n-ships"></span></div>
            <div class="stat-row"><span>è»ã®è³ª:</span> <span id="n-qual"></span></div>
            <button id="btn-history" style="margin-top:10px; background:#5d4037;">å›½å®¶ç³»è­œã‚’è¦‹ã‚‹</button>
        </div>

        <div class="panel">
            <h2>ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°</h2>
            <div id="log"></div>
        </div>
        
        <button id="btn-rulebook" style="margin-top: auto; background: #2c3e50; border-color: #4a69bd;">ğŸ“– ãƒ«ãƒ¼ãƒ«ãƒ–ãƒƒã‚¯ / ã‚·ã‚¹ãƒ†ãƒ è§£èª¬</button>
    </div>
</div>

<script>
/**
 * å®šæ•°ã¨è¨­å®š
 */
const TILE_SIZE = 6; // æç”»æ™‚ã®1ã‚¿ã‚¤ãƒ«ã®ãƒ”ã‚¯ã‚»ãƒ«ã‚µã‚¤ã‚º
const COLORS = {
    WATER: '#1a2a3a',
    LAND: '#3c4d3c',
    MOUNTAIN: '#4a4a4a',
    RIVER: '#2980b9',
    SNOW: '#ecf0f1'
};
const RELIGIONS = ['å¤ªé™½ç¥æ•™', 'æµ·éœŠä¿¡ä»°', 'æ©Ÿæ¢°å´‡æ‹', 'è‡ªç„¶ã®ç§©åº', 'æ··æ²Œ', 'è™šç„¡'];
const TECH_LEVELS = ['åŸå§‹çš„', 'è¾²è€•ç¤¾ä¼š', 'å·¥æ¥­åŒ–', 'ç¾ä»£çš„', 'æœªæ¥çš„'];

const POLITICAL_SYSTEMS = {
    ECONOMIC: ['è‡ªç”±æ”¾ä»»ä¸»ç¾©', 'ç¤¾ä¼šçš„å¸‚å ´çµŒæ¸ˆ', 'æ··åˆçµŒæ¸ˆ', 'è¨ˆç”»çµŒæ¸ˆ', 'çµ±åˆ¶çµŒæ¸ˆ', 'å”åŒçµ„åˆä¸»ç¾©', 'é‡å•†ä¸»ç¾©', 'è¾²æœ¬ä¸»ç¾©'],
    BROAD: ['æ°‘ä¸»ä¸»ç¾©', 'æ¨©å¨ä¸»ç¾©', 'å…¨ä½“ä¸»ç¾©'],
    DETAILED: {
        'æ°‘ä¸»ä¸»ç¾©': ['è­°é™¢å†…é–£åˆ¶', 'å¤§çµ±é ˜åˆ¶', 'åŠå¤§çµ±é ˜åˆ¶', 'äºŒå…ƒä»£è¡¨åˆ¶'],
        'æ¨©å¨ä¸»ç¾©': ['çµ¶å¯¾å›ä¸»åˆ¶', 'ç«‹æ†²å›ä¸»åˆ¶', 'è»äº‹è©•è­°ä¼šåˆ¶', 'é¸æŒ™å›ä¸»åˆ¶', 'å€‹äººç‹¬è£åˆ¶'],
        'å…¨ä½“ä¸»ç¾©': ['ä¸€å…šç‹¬è£åˆ¶', 'ç¥æ¨©æ”¿æ²»', 'å‰è¡›å…šç‹¬è£', 'è»äº‹ç‹¬è£åˆ¶']
    },
    STRUCTURE: ['å˜ä¸€å›½å®¶', 'é€£é‚¦å›½å®¶', 'å›½å®¶é€£åˆ'],
    SOVEREIGN: {
        'æ°‘ä¸»ä¸»ç¾©': ['å›½æ°‘'],
        'æ¨©å¨ä¸»ç¾©': ['å›ä¸»', 'ç‹¬è£è€…', 'è»éƒ¨', 'è²´æ—è­°ä¼š'],
        'å…¨ä½“ä¸»ç¾©': ['å…š', 'å®—æ•™æŒ‡å°è€…', 'ç‹¬è£è€…']
    }
};

function generatePoliticalSystem(currentTech) {
    // 1. Broad Framework (Weight by Tech)
    let broad;
    if (currentTech < 2) { // Primitive/Agrarian -> mostly Authoritarian
        broad = Math.random() < 0.8 ? 'æ¨©å¨ä¸»ç¾©' : (Math.random() < 0.5 ? 'å…¨ä½“ä¸»ç¾©' : 'æ°‘ä¸»ä¸»ç¾©');
    } else {
        broad = POLITICAL_SYSTEMS.BROAD[Math.floor(Math.random() * POLITICAL_SYSTEMS.BROAD.length)];
    }
    
    // 2. Detailed System
    const details = POLITICAL_SYSTEMS.DETAILED[broad];
    const detailed = details[Math.floor(Math.random() * details.length)];
    
    // 3. Sovereign
    let sovereigns = POLITICAL_SYSTEMS.SOVEREIGN[broad];
    // Specific logic overrides
    if (detailed.includes('å›ä¸»')) {
        sovereigns = ['å›ä¸»'];
    } else if (detailed.includes('è»äº‹')) {
        sovereigns = ['è»éƒ¨', 'ç‹¬è£è€…'];
    } else if (detailed.includes('ç¥æ¨©')) {
        sovereigns = ['å®—æ•™æŒ‡å°è€…', 'ç¥'];
    }
    const sovereign = sovereigns[Math.floor(Math.random() * sovereigns.length)];

    // 4. State Structure
    const structure = POLITICAL_SYSTEMS.STRUCTURE[Math.floor(Math.random() * POLITICAL_SYSTEMS.STRUCTURE.length)];

    // 5. Economic Ideology
    let possibleEcos = [...POLITICAL_SYSTEMS.ECONOMIC];
    // Filter based on era/tech
    if (currentTech < 2) {
        possibleEcos = ['é‡å•†ä¸»ç¾©', 'è¾²æœ¬ä¸»ç¾©', 'çµ±åˆ¶çµŒæ¸ˆ'];
    } else {
        // Filter based on politics
        if (broad === 'å…¨ä½“ä¸»ç¾©' || detailed.includes('è¨ˆç”»') || detailed.includes('ç¤¾ä¼šä¸»ç¾©')) {
             possibleEcos = ['è¨ˆç”»çµŒæ¸ˆ', 'çµ±åˆ¶çµŒæ¸ˆ'];
        } else if (broad === 'æ°‘ä¸»ä¸»ç¾©') {
             possibleEcos = ['è‡ªç”±æ”¾ä»»ä¸»ç¾©', 'ç¤¾ä¼šçš„å¸‚å ´çµŒæ¸ˆ', 'æ··åˆçµŒæ¸ˆ', 'å”åŒçµ„åˆä¸»ç¾©'];
        } else if (detailed.includes('çµ¶å¯¾å›ä¸»')) {
             possibleEcos = ['é‡å•†ä¸»ç¾©', 'çµ±åˆ¶çµŒæ¸ˆ', 'æ··åˆçµŒæ¸ˆ', 'è¾²æœ¬ä¸»ç¾©'];
        }
    }
    // Fallback if empty (shouldn't happen but safety)
    if (possibleEcos.length === 0) possibleEcos = POLITICAL_SYSTEMS.ECONOMIC;
    
    const eco = possibleEcos[Math.floor(Math.random() * possibleEcos.length)];

    return {
        sysBroad: broad,
        sysDetailed: detailed,
        sovereign: sovereign,
        stateStruct: structure,
        ecoIdeology: eco
    };
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
let canvas, ctx, width, height;
let grid = []; // 0:Water, 1:Land, 2:Mountain, 3:River
let ownerGrid = []; // ID of the nation owning this tile (-1 for none)
let nations = [];
let nationIdCounter = 0;
let isDrawing = true;
let isFillMode = false;
let currentBrush = 1; // 1:Land, 0:Water
let mapMode = 'political'; // political or terrain
let mapScale = 1.0;
let isPaused = true;
let simSpeed = 5;
let frameCounter = 0;
let worldTension = 0;
let year = 1;
let animationFrame;
let selectedNationId = -1;
let continentMap = [];
let mapDirty = true;
let hegemonId = -1;
let hegemonStatus = "";

// ãƒã‚¦ã‚¹æ“ä½œç”¨
let mousePressed = false;
let mouseButton = 0; // 0:Left, 2:Right

function isNationNameTaken(name, excludeId = -1) {
    return nations.some(n => n.id !== excludeId && n.name === name);
}

function isBaseNameTaken(name, excludeId = -1) {
    return nations.some(n => n.id !== excludeId && n.baseName === name);
}

function isCityNameTaken(name) {
    for (const n of nations) {
        if (n.cities.some(c => c.name === name)) return true;
    }
    return false;
}

function updateContinents() {
    continentMap = new Array(width * height).fill(-1);
    let currentContinentId = 0;
    
    for (let i = 0; i < width * height; i++) {
        // Skip water or already visited
        if (grid[i] === 0 || continentMap[i] !== -1) continue;
        
        // Start BFS
        let queue = [i];
        continentMap[i] = currentContinentId;
        
        while(queue.length > 0) {
            let curr = queue.shift();
            let cx = curr % width;
            let cy = Math.floor(curr / width);
            
            [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
                let nx = cx + dx;
                let ny = cy + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    let nIdx = ny * width + nx;
                    if (grid[nIdx] !== 0 && continentMap[nIdx] === -1) {
                        continentMap[nIdx] = currentContinentId;
                        queue.push(nIdx);
                    }
                }
            });
        }
        currentContinentId++;
    }
}

/**
 * åˆæœŸåŒ–
 */
window.onload = () => {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    
    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºèª¿æ•´
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // ã‚°ãƒªãƒƒãƒ‰åˆæœŸåŒ– (ç”»é¢ã‚µã‚¤ã‚ºã«å¿œã˜ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š)
    let defaultSize = 128;
    if (window.innerWidth <= 768) {
        defaultSize = 64; // ã‚¹ãƒãƒ›ãªã©ã¯å°ã‚µã‚¤ã‚º
    }
    document.getElementById('mapSize').value = defaultSize;
    initGrid(defaultSize);

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    setupInput();
    
    // ãƒ«ãƒ¼ãƒ—é–‹å§‹
    loop();
};

function resizeCanvas() {
    const container = document.getElementById('canvas-wrapper');
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
}

function initGrid(size) {
    width = size;
    height = size;
    grid = new Array(width * height).fill(0);
    ownerGrid = new Array(width * height).fill(-1);
    continentMap = new Array(width * height).fill(-1);
    nations = [];
    isDrawing = true;
    year = 1;
    document.getElementById('log').innerHTML = '';
}

/**
 * å…¥åŠ›å‡¦ç†
 */
function setupInput() {
    // æç”»ãƒ„ãƒ¼ãƒ«
    canvas.addEventListener('mousedown', e => {
        mousePressed = true;
        mouseButton = e.button;
        handleDraw(e);
        handleSelect(e);
    });
    canvas.addEventListener('mousemove', e => {
        handleDraw(e);
        handleHover(e);
    });
    window.addEventListener('mouseup', () => mousePressed = false);

    // ã‚¿ãƒƒãƒæ“ä½œå¯¾å¿œ
    canvas.addEventListener('touchstart', e => {
        mousePressed = true;
        mouseButton = 0; // ã‚¿ãƒƒãƒã¯å·¦ã‚¯ãƒªãƒƒã‚¯æ‰±ã„
        handleDraw(e);
        handleSelect(e);
        e.preventDefault();
    }, { passive: false });
    canvas.addEventListener('touchmove', e => {
        handleDraw(e);
        handleHover(e);
        e.preventDefault();
    }, { passive: false });
    canvas.addEventListener('touchend', () => {
        mousePressed = false;
    });
    
    // å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç„¡åŠ¹åŒ–
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // UIãƒœã‚¿ãƒ³
    document.getElementById('mapSize').addEventListener('change', (e) => {
        initGrid(parseInt(e.target.value));
    });

    document.getElementById('btn-generate').addEventListener('click', () => {
        generateWorld();
    });

    document.getElementById('btn-pause').addEventListener('click', () => {
        isPaused = !isPaused;
    });

    document.getElementById('btn-map-mode').addEventListener('click', (e) => {
        mapMode = (mapMode === 'political' ? 'terrain' : 'political');
        e.target.innerText = `åœ°å›³ãƒ¢ãƒ¼ãƒ‰: ${mapMode === 'political' ? 'æ”¿æ²»' : 'åœ°å½¢'}`;
    });

    document.getElementById('simSpeed').addEventListener('input', (e) => {
        simSpeed = parseInt(e.target.value);
    });

    document.getElementById('btn-fill').addEventListener('click', (e) => {
        isFillMode = !isFillMode;
        e.target.innerText = `å¡—ã‚Šã¤ã¶ã—ãƒ¢ãƒ¼ãƒ‰: ${isFillMode ? 'ã‚ªãƒ³' : 'ã‚ªãƒ•'}`;
        e.target.style.background = isFillMode ? '#4db8ff' : '#34495e';
        e.target.style.color = isFillMode ? '#000' : '#ecf0f1';
    });

    document.getElementById('btn-brush').addEventListener('click', (e) => {
        currentBrush = currentBrush === 1 ? 0 : 1;
        e.target.innerText = `ãƒ–ãƒ©ã‚·: ${currentBrush === 1 ? 'é™¸åœ°' : 'æµ·'}`;
        e.target.style.background = currentBrush === 1 ? '#34495e' : '#2980b9';
    });

    document.getElementById('btn-history').addEventListener('click', () => {
        if (selectedNationId === -1) return;
        const n = nations.find(nat => nat.id === selectedNationId);
        if (!n) return;
        
        const list = document.getElementById('history-list');
        list.innerHTML = '';
        
        n.history.forEach(h => {
            const item = document.createElement('div');
            item.style.marginBottom = "5px";
            item.style.borderBottom = "1px solid #333";
            item.style.paddingBottom = "2px";
            item.innerText = `[Y${h.year}] ${h.event}`;
            list.appendChild(item);
        });
        
        document.getElementById('history-modal').style.display = 'block';
    });

    document.getElementById('btn-rulebook').addEventListener('click', () => {
        document.getElementById('rulebook-modal').style.display = 'block';
    });

    document.getElementById('btn-ranking').addEventListener('click', () => {
        openRankingModal();
    });
}

function openRankingModal() {
    document.getElementById('ranking-modal').style.display = 'block';
    renderRankingContent();
}

function renderRankingContent() {
    const content = document.getElementById('ranking-content');
    // Save scroll position
    const modal = document.getElementById('ranking-modal');
    const scrollTop = modal ? modal.scrollTop : 0;

    content.innerHTML = '';

    // Prepare Ranking Data (Aggregate Puppets)
    const rankingData = [];
    const activeNations = nations.filter(n => !n.isDead);

    // 1. Initialize with independent nations
    activeNations.forEach(n => {
        if (!n.isPuppet) {
            rankingData.push({
                id: n.id,
                name: n.name,
                color: n.color,
                gdp: n.gdp,
                pop: n.pop,
                military: n.getMilitaryPower(),
                tiles: n.tiles.length,
                isBloc: false
            });
        }
    });

    // 2. Add puppet stats to masters
    activeNations.forEach(n => {
        if (n.isPuppet && n.masterId !== -1) {
            const masterData = rankingData.find(d => d.id === n.masterId);
            if (masterData) {
                masterData.gdp += n.gdp;
                masterData.pop += n.pop;
                masterData.military += n.getMilitaryPower();
                masterData.tiles += n.tiles.length;
                masterData.isBloc = true;
            }
        }
    });

    // 3. Update names and calculate score
    rankingData.forEach(d => {
        if (d.isBloc) {
            d.name = `${d.name}(${d.name}åœ)`;
        }
        d.score = Math.floor(d.gdp + (d.pop / 100) + (d.military * 10) + (d.tiles * 50));
    });

    const createTable = (title, list, valueFn, formatFn) => {
        const section = document.createElement('div');
        section.innerHTML = `<h3 class="ranking-section-title">${title}</h3>`;
        
        const table = document.createElement('table');
        table.className = 'ranking-table';
        
        // Header
        const thead = document.createElement('thead');
        thead.innerHTML = `<tr><th style="width:30px">#</th><th>å›½å®¶å</th><th style="width: 40%;"></th><th style="text-align:right;">${title.split(' ')[0]}</th></tr>`;
        table.appendChild(thead);
        
        // Body
        const tbody = document.createElement('tbody');
        // list is already processed rankingData
        const sorted = list.slice().sort((a, b) => valueFn(b) - valueFn(a)).slice(0, 10);
        
        const maxVal = sorted.length > 0 ? valueFn(sorted[0]) : 1;

        sorted.forEach((d, index) => {
            const tr = document.createElement('tr');
            const val = valueFn(d);
            const percent = (val / maxVal) * 100;
            tr.innerHTML = `
                <td>${index + 1}</td>
                <td style="color:${d.color}; font-weight:bold;">${d.name}</td>
                <td>
                    <div class="rank-bar-container">
                        <div class="rank-bar" style="width: ${percent}%; background-color: ${d.color};"></div>
                    </div>
                </td>
                <td style="text-align:right;">${formatFn ? formatFn(val) : val}</td>
            `;
            tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        section.appendChild(table);
        return section;
    };

    // 0. Total Score
    content.appendChild(createTable('ç·åˆå›½åŠ›ã‚¹ã‚³ã‚¢', rankingData, d => d.score, val => formatNum(val)));

    // 1. GDP
    content.appendChild(createTable('GDP (çµŒæ¸ˆåŠ›)', rankingData, d => d.gdp, val => formatNum(val)));
    
    // 2. Population
    content.appendChild(createTable('äººå£', rankingData, d => d.pop, val => formatNum(val)));
    
    // 3. Military Power
    content.appendChild(createTable('è»äº‹åŠ› (æ¨å®š)', rankingData, d => Math.floor(d.military), val => formatNum(val)));
    
    // 4. Territory (Tiles)
    content.appendChild(createTable('é ˜åœŸé¢ç© (ã‚¿ã‚¤ãƒ«æ•°)', rankingData, d => d.tiles, val => val));

    // Restore scroll position
    if (modal) modal.scrollTop = scrollTop;
}

/**
 * æç”»ãƒ¢ãƒ¼ãƒ‰ã®å‡¦ç†
 */
function handleDraw(e) {
    if (!mousePressed || !isDrawing) return;
    
    const {x, y} = getGridPos(e);

    if (x >= 0 && x < width && y >= 0 && y < height) {
        const targetType = (e.type.startsWith('touch') || mouseButton === 0) ? currentBrush : (currentBrush === 1 ? 0 : 1);
        
        if (isFillMode) {
            // å¡—ã‚Šã¤ã¶ã—ï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ãŸç¬é–“ã®ã¿å®Ÿè¡Œã—ãŸã„ãŒã€mousedownã§ã‚‚å‘¼ã°ã‚Œã‚‹ã®ã§OKï¼‰
            // mousemoveä¸­ã«å¡—ã‚Šã¤ã¶ã—ã‚’é€£æ‰“ã™ã‚‹ã¨é‡ã„ã®ã§ã€mousedownã®æ™‚ã ã‘ã«ã™ã‚‹å·¥å¤«ãŒå¿…è¦
            if (e.type === 'mousedown' || e.type === 'touchstart') {
                floodFill(x, y, targetType);
                mapDirty = true;
            }
        } else {
            // ãƒ–ãƒ©ã‚·ã‚µã‚¤ã‚ºï¼ˆå°‘ã—å¤ªãï¼‰
            for(let dy=-1; dy<=1; dy++){
                for(let dx=-1; dx<=1; dx++){
                    const nx = x+dx;
                    const ny = y+dy;
                    if(nx>=0 && nx<width && ny>=0 && ny<height){
                        const idx = ny * width + nx;
                        if (grid[idx] !== targetType) {
                            grid[idx] = targetType;
                            mapDirty = true;
                        }
                    }
                }
            }
        }
    }
}

function floodFill(startX, startY, newType) {
    const oldType = grid[startY * width + startX];
    if (oldType === newType) return;

    const stack = [[startX, startY]];
    while (stack.length > 0) {
        const [x, y] = stack.pop();
        const idx = y * width + x;

        if (grid[idx] === oldType) {
            grid[idx] = newType;

            if (x > 0) stack.push([x - 1, y]);
            if (x < width - 1) stack.push([x + 1, y]);
            if (y > 0) stack.push([x, y - 1]);
            if (y < height - 1) stack.push([x, y + 1]);
        }
    }
}

/**
 * é¸æŠã¨ãƒ›ãƒãƒ¼
 */
function handleSelect(e) {
    if (isDrawing) return;
    const {x, y} = getGridPos(e);
    if (x >= 0 && x < width && y >= 0 && y < height) {
        const idx = y * width + x;
        const owner = ownerGrid[idx];
        if (owner !== -1) {
            selectedNationId = owner;
            updateNationPanel();
            document.getElementById('nation-panel').style.display = 'block';
        } else {
            document.getElementById('nation-panel').style.display = 'none';
            selectedNationId = -1;
        }
    }
}

function handleHover(e) {
    const hoverInfo = document.getElementById('hover-info');
    if (isDrawing) {
        hoverInfo.style.display = 'none';
        return;
    }
    
    const {x, y} = getGridPos(e);
    if (x >= 0 && x < width && y >= 0 && y < height) {
        const idx = y * width + x;
        const owner = ownerGrid[idx];
        if (owner !== -1) {
            const n = nations.find(nat => nat.id === owner);
            if(n) {
                const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
                const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
                hoverInfo.style.display = 'block';
                hoverInfo.style.left = (clientX + 10) + 'px';
                hoverInfo.style.top = (clientY + 10) + 'px';
                hoverInfo.innerHTML = `<b>${n.name}</b><br>äººå£: ${formatNum(n.pop)}`;
                return;
            }
        }
    }
    hoverInfo.style.display = 'none';
}

function getGridPos(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
    const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
    
    const relX = clientX - rect.left - canvas.width/2;
    const relY = clientY - rect.top - canvas.height/2;
    const x = Math.floor((relX / mapScale + (width*TILE_SIZE)/2) / TILE_SIZE);
    const y = Math.floor((relY / mapScale + (height*TILE_SIZE)/2) / TILE_SIZE);
    return {x, y};
}

/**
 * ãƒ¯ãƒ¼ãƒ«ãƒ‰ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯
 */
function generateWorld() {
    isDrawing = false;
    document.getElementById('menu-panel').style.display = 'none';
    document.getElementById('sim-panel').style.display = 'block';

    // 1. åœ°å½¢è£œæ­£ (å±±ã¨å·)
    generateTerrainFeatures();

    // 2. å›½å®¶ç”Ÿæˆ
    spawnNations();
    
    // 3. å¤§é™¸æƒ…å ±ã®æ›´æ–°
    updateContinents();

    log("ä¸–ç•ŒãŒç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚æ­´å²ãŒå§‹ã¾ã‚Šã¾ã™ã€‚", "log-info");
}

function generateTerrainFeatures() {
    // 1. æµ·å²¸ç·šã‹ã‚‰ã®è·é›¢ãƒãƒƒãƒ—ã‚’ä½œæˆ (2ãƒ‘ã‚¹ãƒ»ãƒ‡ã‚£ã‚¹ã‚¿ãƒ³ã‚¹ãƒ»ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ )
    let distMap = new Array(width * height).fill(width * height);
    
    // ãƒ‘ã‚¹1: å·¦ä¸Šã‹ã‚‰å³ä¸‹ã¸
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            let idx = y * width + x;
            if (grid[idx] === 0) {
                distMap[idx] = 0;
            } else {
                let left = (x > 0) ? distMap[idx - 1] : width * height;
                let top = (y > 0) ? distMap[idx - width] : width * height;
                distMap[idx] = Math.min(distMap[idx], Math.min(left, top) + 1);
            }
        }
    }
    // ãƒ‘ã‚¹2: å³ä¸‹ã‹ã‚‰å·¦ä¸Šã¸
    for (let y = height - 1; y >= 0; y--) {
        for (let x = width - 1; x >= 0; x--) {
            let idx = y * width + x;
            if (grid[idx] !== 0) {
                let right = (x < width - 1) ? distMap[idx + 1] : width * height;
                let bottom = (y < height - 1) ? distMap[idx + width] : width * height;
                distMap[idx] = Math.min(distMap[idx], Math.min(right, bottom) + 1);
            }
        }
    }

    // 2. å±±è„ˆã®ç”Ÿæˆ (å³¶ã®ä¸­å¤®éƒ¨ã€ã¤ã¾ã‚Šè·é›¢ãŒæ¥µå¤§ã«ãªã‚‹ä»˜è¿‘ã«æ²¿ã£ã¦ç”Ÿæˆ)
    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            let idx = y * width + x;
            if (grid[idx] === 1 && distMap[idx] >= 4) {
                let isLocalMax = true;
                let val = distMap[idx];
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        if (distMap[(y + dy) * width + (x + dx)] > val) {
                            isLocalMax = false;
                            break;
                        }
                    }
                    if (!isLocalMax) break;
                }
                
                if (isLocalMax && Math.random() < 0.8) {
                    grid[idx] = 2; // å±±
                    // å±±è„ˆã‚’åºƒã’ã‚‹ (å±±è„ˆã®æ–¹å‘ã«æ…£æ€§ã‚’æŒãŸã›ã‚‹)
                    let cx = x, cy = y;
                    let lastDx = 0, lastDy = 0;
                    let rangeLen = 5 + Math.random() * 20;
                    for (let len = 0; len < rangeLen; len++) {
                        let candidates = [];
                        [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]].forEach(([dx, dy]) => {
                            let nx = cx + dx, ny = cy + dy;
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                let nIdx = ny * width + nx;
                                if (grid[nIdx] === 1 && distMap[nIdx] >= 3) {
                                    // å‰å›ã®æ–¹å‘ã¨åŒã˜æ–¹å‘ã‚’å„ªå…ˆ
                                    let weight = (dx === lastDx && dy === lastDy) ? 5 : 1;
                                    for(let w=0; w<weight; w++) candidates.push({x: nx, y: ny, dx, dy});
                                }
                            }
                        });
                        if (candidates.length === 0) break;
                        let next = candidates[Math.floor(Math.random() * candidates.length)];
                        cx = next.x; cy = next.y;
                        lastDx = next.dx; lastDy = next.dy;
                        grid[cy * width + cx] = 2;
                    }
                }
            }
        }
    }

    // 3. å·ã®ç”Ÿæˆ (å±±ã‹ã‚‰æµ·ã¸ã€å‹¾é…ã‚’ä¸‹ã‚‹)
    let riverOrigins = [];
    for (let i = 0; i < width * height; i++) {
        if (grid[i] === 2 && Math.random() < 0.3) riverOrigins.push(i);
    }
    
    riverOrigins.forEach(origin => {
        let cx = origin % width;
        let cy = Math.floor(origin / width);
        let path = [origin];
        let life = 200;
        while (life > 0) {
            let candidates = [];
            let currentH = distMap[cy * width + cx];
            
            [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                let nx = cx + dx, ny = cy + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    let idx = ny * width + nx;
                    if (path.includes(idx)) return;
                    let h = distMap[idx];
                    if (h <= currentH) {
                        candidates.push({x: nx, y: ny, h: h, idx: idx});
                    }
                }
            });

            if (candidates.length === 0) break;
            // å‹¾é…ãŒæœ€ã‚‚æ€¥ãªæ–¹å‘ã‚’å„ªå…ˆã—ã¤ã¤ã€å°‘ã—ãƒ©ãƒ³ãƒ€ãƒ æ€§ã‚’å…¥ã‚Œã‚‹
            candidates.sort((a, b) => a.h - b.h);
            let next = candidates[0];
            if (Math.random() < 0.4 && candidates.length > 1) next = candidates[Math.floor(Math.random() * Math.min(candidates.length, 3))];
            
            cx = next.x; cy = next.y;
            path.push(next.idx);
            if (grid[next.idx] === 0) break; // æµ·ã«åˆ°é”
            if (grid[next.idx] === 1) grid[next.idx] = 3; // å¹³åœ°ãªã‚‰å·ã«ã™ã‚‹
            life--;
        }
    });
}

/**
 * éƒ½å¸‚ã‚¯ãƒ©ã‚¹
 */
class City {
    constructor(name, tileIdx, nationId) {
        this.name = name;
        this.tileIdx = tileIdx;
        this.nationId = nationId;
        this.unrest = 0;
    }
}

/**
 * å›½å®¶ã‚¯ãƒ©ã‚¹
 */
class Nation {
    constructor(id, x, y) {
        this.id = (id !== undefined) ? id : nationIdCounter++;
        this.color = `hsl(${Math.random()*360}, 70%, 50%)`;
        this.baseName = this.generateBaseName();
        this.regimeNumber = 1;
        this.religion = RELIGIONS[Math.floor(Math.random() * RELIGIONS.length)];
        
        // Stats
        this.pop = 1000 + Math.floor(Math.random() * 5000);
        this.gdp = 100 + Math.floor(Math.random() * 900); // 1äººã‚ãŸã‚Šã§ã¯ãªã„ã€å›½åŠ›ãƒ™ãƒ¼ã‚¹
        this.industry = 10 + Math.floor(Math.random() * 50);
        this.tech = 0; // Index of TECH_LEVELS
        
        // Politics
        const system = generatePoliticalSystem(this.tech);
        this.sysBroad = system.sysBroad;
        this.sysDetailed = system.sysDetailed;
        this.sovereign = system.sovereign;
        this.stateStruct = system.stateStruct;
        this.ecoIdeology = system.ecoIdeology;
        
        this.govType = this.sysDetailed; // Backward compatibility

        // Grand Empire Logic (Rare Spawn)
        this.isGrandEmpire = false;
        if (Math.random() < 0.05) {
            this.isGrandEmpire = true;
            this.sysBroad = 'æ¨©å¨ä¸»ç¾©';
            this.sysDetailed = 'çµ¶å¯¾å›ä¸»åˆ¶';
            this.sovereign = 'å›ä¸»';
            this.govType = this.sysDetailed;
            
            // Boost stats
            this.pop = Math.floor(this.pop * 1.5);
            this.gdp = Math.floor(this.gdp * 2.0);
            this.soldiers = Math.floor(this.soldiers * 2.0);
            this.soldierQuality += 0.5;
            this.color = `hsl(${Math.random()*360}, 100%, 30%)`; // Darker, more intense color
        }

        this.updateName();
        this.stability = 100;
        this.governance = (this.sysBroad === 'æ°‘ä¸»ä¸»ç¾©' ? 60 : (this.sysBroad === 'å…¨ä½“ä¸»ç¾©' ? 70 : 50)) + (this.tech * 5);
        this.unrest = 0;
        this.leader = this.generateLeaderName();
        
        // Military
        this.soldiers = Math.floor(this.pop * 0.1);
        this.soldierQuality = 0.5 + Math.random(); // 0.5 - 1.5
        this.equipQuality = 0.5 + Math.random();
        this.tanks = 0;
        this.ships = 0;
        
        // Diplomacy
        this.relations = {}; // { nationId: value (-100 to 100) }
        this.atWarWith = []; // list of nation IDs
        this.centroid = {x: 0, y: 0};
        this.isDead = false;
        this.isRebel = false;
        this.parentName = "";
        this.rebellionCooldown = 0;
        this.isPuppet = false;
        this.masterId = -1;
        this.puppetSince = 0;
        
        this.cities = [];
        this.history = [];

        // åˆæœŸé ˜åœŸ
        if (x !== undefined && y !== undefined) {
            const tileIdx = y * width + x;
            ownerGrid[tileIdx] = this.id;
            this.tiles = [tileIdx];
            // åˆæœŸéƒ½å¸‚ï¼ˆé¦–éƒ½ï¼‰ã®ç”Ÿæˆ
            this.cities.push(new City(this.baseName + "åºœ", tileIdx, this.id));
            this.addHistory("å»ºå›½ (Founded)");
        } else {
            this.tiles = [];
        }
    }

    addHistory(event) {
        this.history.push({ year: year, event: event });
    }

    generateBaseName() {
        const syl = ["ã‚¢ãƒ«", "ãƒãƒ³", "ã‚·ãƒ¼", "ãƒ‰ãƒ«", "ã‚¨ãƒ«", "ãƒ•ã‚¡", "ã‚´ãƒ«", "ãƒãƒ³", "ã‚¤ãƒ«", "ã‚¸ãƒ§", "ã‚«", "ãƒ­ãƒ«", "ãƒŸ", "ãƒãƒ«", "ãƒ‘", "ã‚¯", "ãƒ­", "ã‚µ", "ãƒ†ã‚£", "ã‚¦ãƒ«", "ãƒ´ã‚¡", "ã‚­", "ã‚º"];
        for(let i=0; i<100; i++) {
            let name = syl[Math.floor(Math.random()*syl.length)] + syl[Math.floor(Math.random()*syl.length)];
            if (!isBaseNameTaken(name, this.id)) return name;
        }
        return syl[Math.floor(Math.random()*syl.length)] + syl[Math.floor(Math.random()*syl.length)] + Math.floor(Math.random()*100);
    }

    generateCityName() {
        const syl = ["ã‚¢ãƒ«", "ãƒãƒ³", "ã‚·ãƒ¼", "ãƒ‰ãƒ«", "ã‚¨ãƒ«", "ãƒ•ã‚¡", "ã‚´ãƒ«", "ãƒãƒ³", "ã‚¤ãƒ«", "ã‚¸ãƒ§", "ã‚«", "ãƒ­ãƒ«", "ãƒŸ", "ãƒãƒ«", "ãƒ‘", "ã‚¯", "ãƒ­", "ã‚µ", "ãƒ†ã‚£", "ã‚¦ãƒ«", "ãƒ´ã‚¡", "ã‚­", "ã‚º"];
        const suffix = ["å¸‚", "åºœ", "äº¬", "è¦å¡", "æ¸¯", "éƒ½"];
        for(let i=0; i<100; i++) {
            let name = syl[Math.floor(Math.random()*syl.length)] + syl[Math.floor(Math.random()*syl.length)] + suffix[Math.floor(Math.random()*suffix.length)];
            if (!isCityNameTaken(name)) return name;
        }
        return syl[Math.floor(Math.random()*syl.length)] + syl[Math.floor(Math.random()*syl.length)] + suffix[Math.floor(Math.random()*suffix.length)] + Math.floor(Math.random()*100);
    }

    updateName() {
        let proposedName = "";
        if (this.isPuppet) {
            let masterName = "";
            if (this.masterId !== -1) {
                const master = nations.find(m => m.id === this.masterId);
                if (master) masterName = master.name;
            }
            if (masterName) {
                proposedName = masterName + "é ˜" + this.baseName;
            } else {
                proposedName = this.baseName + "å‚€å„¡çµ±æ²»æ©Ÿæ§‹å›½";
            }
        } else {
            if (this.isGrandEmpire) {
                proposedName = "å¤§" + this.baseName + "å¸å›½";
            } else {
                let suffix = "å›½";

                // Suffix logic based on detailed political system
                if (this.sysDetailed.includes('å›ä¸»') || this.sovereign === 'å›ä¸»') {
                    if (this.sysDetailed === 'å¸å›½' || (this.id % 5 === 0)) suffix = "å¸å›½";
                    else suffix = "ç‹å›½";
                    if (this.sysDetailed === 'å…¬å›½') suffix = "å…¬å›½";
                } else if (this.sysDetailed.includes('è»äº‹') || this.sovereign === 'è»éƒ¨') {
                    suffix = "è»äº‹æ”¿æ¨©";
                } else if (this.sysDetailed.includes('ç¥æ¨©') || this.sovereign === 'å®—æ•™æŒ‡å°è€…') {
                    suffix = "ç¥è–å›½";
                } else if (this.sysBroad === 'æ°‘ä¸»ä¸»ç¾©') {
                    suffix = "å…±å’Œå›½";
                    if (this.stateStruct === 'é€£é‚¦å›½å®¶') suffix = "é€£é‚¦" + suffix;
                    if (this.stateStruct === 'å›½å®¶é€£åˆ') suffix = "é€£åˆ";
                    if (this.sysDetailed === 'å¤§çµ±é ˜åˆ¶' && this.stateStruct === 'é€£é‚¦å›½å®¶') suffix = "åˆè¡†å›½"; // Flavor override
                } else if (this.sysBroad === 'å…¨ä½“ä¸»ç¾©') {
                    if (this.ecoIdeology.includes('è¨ˆç”»') || this.ecoIdeology.includes('çµ±åˆ¶')) suffix = "ç¤¾ä¼šä¸»ç¾©å…±å’Œå›½";
                    else suffix = "ç‹¬è£å›½";
                }
                
                // Special cases
                if (this.sysDetailed === "é©å‘½æ”¿åºœ") suffix = "é©å‘½æ”¿åºœ";
                if (this.sysDetailed === "è‡¨æ™‚æ”¿åºœ") suffix = "è‡¨æ™‚æ”¿åºœ";
                if (this.sysDetailed === "æ­£çµ±æ”¿åºœ") suffix = "æ­£çµ±æ”¿åºœ";

                if (this.sysBroad === 'æ°‘ä¸»ä¸»ç¾©' && this.regimeNumber > 1) {
                    proposedName = this.baseName + suffix + "ç¬¬" + this.regimeNumber + "æ”¿";
                } else {
                    proposedName = this.baseName + suffix;
                }
            }
        }

        // Ensure uniqueness
        if (!isNationNameTaken(proposedName, this.id)) {
            this.name = proposedName;
        } else {
            // Check if we should use "Nth Regime" numbering
            const isDemocracy = this.sysBroad === 'æ°‘ä¸»ä¸»ç¾©';
            
            if (isDemocracy) {
                let baseString = proposedName;
                let startNum = 2;
                
                // Check if already ends in "ç¬¬Næ”¿"
                const match = proposedName.match(/ç¬¬(\d+)æ”¿$/);
                if (match) {
                    baseString = proposedName.substring(0, match.index);
                    startNum = parseInt(match[1]) + 1;
                }

                let finalName = proposedName;
                let counter = startNum;
                
                while (true) {
                    let nextName = baseString + "ç¬¬" + counter + "æ”¿";
                    if (!isNationNameTaken(nextName, this.id)) {
                        finalName = nextName;
                        break;
                    }
                    counter++;
                    if (counter > 1000) {
                        finalName = proposedName + Math.floor(Math.random() * 1000);
                        break;
                    }
                }
                this.name = finalName;
            } else {
                let counter = 2;
                let finalName = proposedName;
                while (true) {
                    let nextName = proposedName + " (" + counter + ")";
                    if (!isNationNameTaken(nextName, this.id)) {
                        finalName = nextName;
                        break;
                    }
                    counter++;
                    if (counter > 100) { 
                        finalName = proposedName + Math.floor(Math.random() * 1000);
                        break;
                    }
                }
                this.name = finalName;
            }
        }

        if (!this.isPuppet) {
            nations.forEach(n => {
                if (n.isPuppet && n.masterId === this.id) {
                    n.updateName();
                }
            });
        }
    }

    generateLeaderName() {
        const first = ["ãƒ¨ãƒãƒ³", "ãƒ•ãƒªãƒ¼ãƒ‰ãƒªãƒ’", "ãƒ«ã‚¤", "ãƒãƒ£ãƒ¼ãƒ«ã‚º", "ã‚¢ãƒ¬ã‚¯ã‚µãƒ³ãƒ€ãƒ¼", "ãƒ‹ã‚³ãƒ©ã‚¤", "ãƒãƒªã‚¢", "ã‚¨ãƒªã‚¶ãƒ™ã‚¹", "ãƒ´ã‚£ã‚¯ãƒˆãƒªã‚¢", "ã‚«ãƒˆãƒªãƒ¼ãƒŒ", "ã‚¹ãƒ¬ã‚¤ãƒãƒ³", "ã‚«ãƒ³ãƒ’", "ãƒ¡ã‚¤ã‚¸", "ã‚°ã‚¹ã‚¿ãƒ•", "ã‚«ãƒ¡ãƒãƒ¡ãƒ"];
        const last = ["ä¸–", "å¤§ç‹", "å…¬", "å¿", "ãƒ»ãƒœãƒŠãƒ‘ãƒ«ãƒˆ", "ãƒ»ãƒ­ãƒãƒãƒ•", "ãƒ»ãƒãƒ—ã‚¹ãƒ–ãƒ«ã‚¯", "ãƒ»ãƒ–ãƒ«ãƒœãƒ³", "ãƒ»ãƒ†ãƒ¥ãƒ¼ãƒ€ãƒ¼", "ãƒ»ãƒ›ãƒ¼ã‚¨ãƒ³ãƒ„ã‚©ãƒ¬ãƒ«ãƒ³"];
        if (Math.random() < 0.7) {
            return first[Math.floor(Math.random() * first.length)] + (Math.random() < 0.5 ? last[Math.floor(Math.random() * last.length)] : "");
        } else {
            // æ—¥æœ¬é¢¨
            const jpFirst = ["ç¹”ç”°", "è±Šè‡£", "å¾³å·", "æ­¦ç”°", "ä¸Šæ‰", "æ¯›åˆ©", "å³¶æ´¥", "ä¼Šé”"];
            const jpLast = ["ä¿¡é•·", "ç§€å‰", "å®¶åº·", "ä¿¡ç„", "è¬™ä¿¡", "å…ƒå°±", "ç¾©ä¹…", "æ”¿å®—"];
            return jpFirst[Math.floor(Math.random() * jpFirst.length)] + jpLast[Math.floor(Math.random() * jpLast.length)];
        }
    }

    getMilitaryPower() {
        // è»äº‹åŠ›è¨ˆç®—å¼: å…µæ•° * è³ª * è£…å‚™ * (æˆ¦è»Šãƒœãƒ¼ãƒŠã‚¹)
        let tankBonus = 1 + (this.tanks * 0.05);
        return this.soldiers * this.soldierQuality * this.equipQuality * tankBonus * (1 + this.tech * 0.5);
    }

    getNavalPower() {
        return this.ships * (1 + this.tech * 0.5) * this.equipQuality;
    }

    updateCentroid() {
        if (this.tiles.length > 0) {
            let sumX = 0, sumY = 0;
            for (let i = 0; i < this.tiles.length; i++) {
                const tileIdx = this.tiles[i];
                sumX += tileIdx % width;
                sumY += Math.floor(tileIdx / width);
            }
            this.centroid.x = sumX / this.tiles.length;
            this.centroid.y = sumY / this.tiles.length;
        }
    }

    isCoastal() {
        // å°‘ãªãã¨ã‚‚1ã¤ã®ã‚¿ã‚¤ãƒ«ãŒæµ·(0)ã«æ¥ã—ã¦ã„ã‚‹ã‹ (ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°)
        const samples = Math.min(this.tiles.length, 30);
        for(let i=0; i<samples; i++) {
            let tile = this.tiles[Math.floor(Math.random() * this.tiles.length)];
            let cx = tile % width;
            let cy = Math.floor(tile / width);
            let found = false;
            [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
                let nx=cx+dx, ny=cy+dy;
                if(nx>=0 && nx<width && ny>=0 && ny<height) {
                    if(grid[ny*width+nx] === 0) found = true;
                }
            });
            if(found) return true;
        }
        return false;
    }
}

function spawnNations() {
    let landTiles = [];
    for(let i=0; i<grid.length; i++) {
        if(grid[i] === 1) landTiles.push(i);
    }

    // åœŸåœ°ã®åºƒã•ã«å¿œã˜ã¦å›½å®¶æ•°ã‚’æ±ºå®š
    const numNations = Math.max(2, Math.floor(landTiles.length / 50)); 
    nationIdCounter = 0;
    
    for(let i=0; i<numNations; i++) {
        if(landTiles.length === 0) break;
        // ãƒ©ãƒ³ãƒ€ãƒ ãªé™¸åœ°ã‚’é¸ã¶
        let rndIdx = Math.floor(Math.random() * landTiles.length);
        let tileIdx = landTiles[rndIdx];
        landTiles.splice(rndIdx, 1);
        
        let y = Math.floor(tileIdx / width);
        let x = tileIdx % width;
        
        // æ—¢ã«èª°ã‹ã®é ˜åœŸãªã‚‰ã‚¹ã‚­ãƒƒãƒ—ï¼ˆåˆæœŸé…ç½®ã¯é›¢ã™ï¼‰
        if(ownerGrid[tileIdx] !== -1) continue;
        
        nations.push(new Nation(undefined, x, y));
    }
    
    // åˆæœŸé ˜åœŸæ‹¡å¤§ (Flood fillçš„)
    expandTerritoryInitial();
}

function expandTerritoryInitial() {
    // ç°¡æ˜“çš„ã«å„å›½ã®å‘¨å›²ã‚’åŸ‹ã‚ã‚‹
    let changed = true;
    let loopCount = 0;
    while(changed && loopCount < 20) {
        changed = false;
        let newOwners = [...ownerGrid];
        
        // ãƒ©ãƒ³ãƒ€ãƒ ãªé †åºã§å‡¦ç†ã™ã‚‹ãŸã‚ã«ã‚·ãƒ£ãƒƒãƒ•ãƒ«
        let indices = Array.from({length: width*height}, (_, i) => i);
        indices.sort(() => Math.random() - 0.5);

        for(let i of indices) {
            if(grid[i] === 0) continue; // æµ·ã¯ç„¡è¦–
            if(ownerGrid[i] !== -1) continue; // æ‰€æœ‰è€…ã‚ã‚Š

            // éš£æ¥ã‚¿ã‚¤ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯
            let neighbors = [];
            let cx = i % width;
            let cy = Math.floor(i / width);
            
            [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
                let nx=cx+dx, ny=cy+dy;
                if(nx>=0 && nx<width && ny>=0 && ny<height) {
                    let nIdx = ny*width+nx;
                    if(ownerGrid[nIdx] !== -1) neighbors.push(ownerGrid[nIdx]);
                }
            });

            if(neighbors.length > 0) {
                // æœ€ã‚‚å¤šã„éš£å›½ã«å¸åã•ã‚Œã‚‹ç¢ºç‡ãŒé«˜ã„
                let chosen = neighbors[Math.floor(Math.random()*neighbors.length)];
                newOwners[i] = chosen;
                nations[chosen].tiles.push(i);
                changed = true;
            }
        }
        ownerGrid = newOwners;
        loopCount++;
    }

    // åˆæœŸé‡å¿ƒè¨ˆç®—
    nations.forEach(n => n.updateCentroid());
}


/**
 * ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—ã¨ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
 */
function loop() {
    ctx.fillStyle = "#222";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    renderMap();
    
    if (!isDrawing && !isPaused) {
        frameCounter++;
        if (frameCounter >= (11 - simSpeed)) {
            frameCounter = 0;
            simulateTick();
            year++;
            document.getElementById('info-year').innerText = year;
            document.getElementById('info-tension').innerText = worldTension.toFixed(1) + "%";
            document.getElementById('info-tension').style.color = `rgb(${worldTension*2.55}, ${255 - worldTension*2.55}, 0)`;
            
            // Top Bar Updates
            document.getElementById('top-ui-year').innerText = year;
            const tVal = worldTension.toFixed(1);
            const tEl = document.getElementById('top-ui-tension');
            tEl.innerText = tVal + "%";
            tEl.style.color = worldTension > 50 ? "#ff6b6b" : "#4db8ff";

            // Hegemon Update
            const hEl = document.getElementById('info-hegemon');
            if (hegemonId !== -1) {
                const h = nations.find(n => n.id === hegemonId);
                if (h) {
                    hEl.innerText = h.name + " (" + hegemonStatus + ")";
                    hEl.style.color = h.color;
                } else {
                    hEl.innerText = "ãªã—";
                    hEl.style.color = "#ccc";
                }
            } else {
                hEl.innerText = "ãªã—";
                hEl.style.color = "#ccc";
            }

            // Real-time Ranking Update
            if (document.getElementById('ranking-modal').style.display === 'block') {
                renderRankingContent();
            }
        }
    }

    if (selectedNationId !== -1) updateNationPanel();

    animationFrame = requestAnimationFrame(loop);
}

function renderMap() {
    // ç”»é¢å…¨ä½“ã«åã¾ã‚‹ã‚ˆã†ã«ã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´ï¼ˆ0.95å€ã®ãƒãƒ¼ã‚¸ãƒ³ã‚’æŒãŸã›ã‚‹ï¼‰
    mapScale = Math.min(canvas.width / (width * TILE_SIZE), canvas.height / (height * TILE_SIZE)) * 0.95;

    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.scale(mapScale, mapScale);
    ctx.translate(-(width * TILE_SIZE) / 2, -(height * TILE_SIZE) / 2);

    const offsetX = 0;
    const offsetY = 0;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = y * width + x;
            const type = grid[i];
            const owner = ownerGrid[i];
            
            let color = COLORS.WATER;
            if (type === 1) color = COLORS.LAND;
            if (type === 2) color = COLORS.MOUNTAIN;
            if (type === 3) color = COLORS.RIVER;

            // å›½ã®è‰²ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
            if (owner !== -1 && !isDrawing) {
                const nat = nations.find(n => n.id === owner);
                if (nat) {
                    if (mapMode === 'political') {
                        // å‚€å„¡å›½ã¯å®—ä¸»å›½ã®è‰²ã‚’ä½¿ç”¨
                        let fillColor = nat.color;
                        if (nat.isPuppet && nat.masterId !== -1) {
                            const master = nations.find(m => m.id === nat.masterId);
                            if (master) fillColor = master.color;
                        }

                        // å›½ã®è‰²ã‚’ãƒ™ãƒ¼ã‚¹ã«ã™ã‚‹ãŒã€åœ°å½¢ã‚‚è¦‹ã›ã‚‹ (é€éã•ã›ã‚‹)
                        ctx.globalAlpha = 0.6;
                        ctx.fillStyle = fillColor;
                        ctx.fillRect(offsetX + x*TILE_SIZE, offsetY + y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        ctx.globalAlpha = 1.0;
                    } else {
                        // åœ°å½¢ã‚’ãƒ™ãƒ¼ã‚¹ã«ã™ã‚‹
                        ctx.fillStyle = color;
                        ctx.fillRect(offsetX + x*TILE_SIZE, offsetY + y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                    
                    // å±±ã‚„å·ã®å ´åˆã¯è£…é£¾ (å¸¸ã«è¡¨ç¤º)
                    if (type === 2) { // å±±
                        ctx.fillStyle = "rgba(0,0,0,0.5)";
                        ctx.fillRect(offsetX + x*TILE_SIZE+1, offsetY + y*TILE_SIZE+1, TILE_SIZE-2, TILE_SIZE-2);
                    }
                    else if (type === 3) { // å·
                        ctx.fillStyle = "rgba(100,200,255,0.6)";
                        ctx.fillRect(offsetX + x*TILE_SIZE + TILE_SIZE/3, offsetY + y*TILE_SIZE, TILE_SIZE/3, TILE_SIZE);
                    }
                }
            } else {
                // æç”»ãƒ¢ãƒ¼ãƒ‰ or é ˜åœŸãªã—
                ctx.fillStyle = color;
                ctx.fillRect(offsetX + x*TILE_SIZE, offsetY + y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }
    }
    
    // å›½å¢ƒç·šã®æç”» (HOI4ã‚¹ã‚¿ã‚¤ãƒ«)
    if (!isDrawing) {
        ctx.lineWidth = 2;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = y * width + x;
                const owner = ownerGrid[i];
                if (owner === -1) continue;

                const rightOwner = (x < width - 1) ? ownerGrid[i + 1] : -2;
                const bottomOwner = (y < height - 1) ? ownerGrid[i + width] : -2;

                if (owner !== rightOwner) {
                    ctx.strokeStyle = "rgba(0,0,0,0.5)";
                    ctx.beginPath();
                    ctx.moveTo(offsetX + (x + 1) * TILE_SIZE, offsetY + y * TILE_SIZE);
                    ctx.lineTo(offsetX + (x + 1) * TILE_SIZE, offsetY + (y + 1) * TILE_SIZE);
                    ctx.stroke();
                }
                if (owner !== bottomOwner) {
                    ctx.strokeStyle = "rgba(0,0,0,0.5)";
                    ctx.beginPath();
                    ctx.moveTo(offsetX + x * TILE_SIZE, offsetY + (y + 1) * TILE_SIZE);
                    ctx.lineTo(offsetX + (x + 1) * TILE_SIZE, offsetY + (y + 1) * TILE_SIZE);
                    ctx.stroke();
                }
            }
        }
    }

    // éƒ½å¸‚ã®æç”»
    if (!isDrawing) {
        nations.forEach(n => {
            if (n.isDead) return;
            n.cities.forEach((city, idx) => {
                const cx = city.tileIdx % width;
                const cy = Math.floor(city.tileIdx / width);
                
                if (idx === 0) {
                    // é¦–éƒ½: æ˜Ÿå½¢
                    drawStar(offsetX + cx*TILE_SIZE + TILE_SIZE/2, offsetY + cy*TILE_SIZE + TILE_SIZE/2, 5, TILE_SIZE*0.8, TILE_SIZE*0.4, "#f1c40f");
                } else {
                    // éƒ½å¸‚ã®å½±/ç¸
                    ctx.fillStyle = "rgba(0,0,0,0.5)";
                    ctx.beginPath();
                    ctx.arc(offsetX + cx*TILE_SIZE + TILE_SIZE/2, offsetY + cy*TILE_SIZE + TILE_SIZE/2, TILE_SIZE/2, 0, Math.PI*2);
                    ctx.fill();
                    
                    // éƒ½å¸‚æœ¬ä½“
                    ctx.fillStyle = "#fff";
                    ctx.beginPath();
                    ctx.arc(offsetX + cx*TILE_SIZE + TILE_SIZE/2, offsetY + cy*TILE_SIZE + TILE_SIZE/2, TILE_SIZE/3, 0, Math.PI*2);
                    ctx.fill();
                }
            });
        });

        // å›½åã®æç”» (HOI4ã‚¹ã‚¿ã‚¤ãƒ«)
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        nations.forEach(n => {
            // å‚€å„¡å›½ã®åå‰ã¯éè¡¨ç¤º
            if (n.isPuppet) return;
            
            if (!n.isDead && n.tiles.length > 30) {
                // mapScaleãŒå°ã•ã„ï¼ˆã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆã—ã¦ã„ã‚‹ï¼‰ã»ã©ã€ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’å¤§ããã—ã¦è¦–èªæ€§ã‚’ç¶­æŒ
                const baseSize = 10 / mapScale;
                const sizeBonus = Math.min(12 / mapScale, (n.tiles.length / 600) / mapScale);
                const fontSize = baseSize + sizeBonus;
                
                ctx.font = `bold ${fontSize}px "Yu Gothic", "SimHei", "Segoe UI", sans-serif`;

                const drawX = offsetX + n.centroid.x * TILE_SIZE;
                const drawY = offsetY + n.centroid.y * TILE_SIZE;
                
                // æ–‡å­—ã®ç¸å–ã‚Š (åšã‚)
                ctx.strokeStyle = "rgba(0,0,0,0.8)";
                ctx.lineWidth = Math.max(3 / mapScale, 2);
                ctx.strokeText(n.name, drawX, drawY);
                
                // æ–‡å­—æœ¬ä½“
                ctx.fillStyle = n.color;
                ctx.fillText(n.name, drawX, drawY);
            }
        });

    }

    // å¤–æ 
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 1;
    ctx.strokeRect(offsetX, offsetY, width*TILE_SIZE, height*TILE_SIZE);

    ctx.restore();

}

function handlePolitics(n) {
    if (n.isDead) return;

    // çµ±æ²»å®‰å®šåº¦ã®æ›´æ–° (æŠ€è¡“ã‚„ä½“åˆ¶ã®å¤‰åŒ–ã‚’åæ˜ )
    n.governance = (n.sysBroad === 'æ°‘ä¸»ä¸»ç¾©' ? 60 : (n.sysBroad === 'å…¨ä½“ä¸»ç¾©' ? 70 : 50)) + (n.tech * 5);

    // å‚€å„¡å›½ã®ç‹¬ç«‹åˆ¤å®š
    if (n.isPuppet) {
        const master = nations.find(m => m.id === n.masterId);
        
        // 1. å®—ä¸»å›½ãŒæ¶ˆæ»…ã—ã¦ã„ã‚‹å ´åˆ -> å³æ™‚ç‹¬ç«‹
        if (!master || master.isDead) {
            declareIndependence(n);
        }
        // 2. æ©Ÿä¼šä¸»ç¾©çš„ç‹¬ç«‹ (å®—ä¸»å›½ãŒä¸å®‰å®šã‹ã¤è‡ªå›½ãŒå®‰å®š)
        else {
            // æµ·ã‚’éš”ã¦ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            let isSeparated = false;
            if (n.tiles.length > 0 && master.tiles.length > 0) {
                 const myTile = n.cities.length > 0 ? n.cities[0].tileIdx : n.tiles[0];
                 const masterTile = master.cities.length > 0 ? master.cities[0].tileIdx : master.tiles[0];
                 // Check if continent map is valid (not -1) and different
                 if (continentMap[myTile] !== -1 && continentMap[masterTile] !== -1 && continentMap[myTile] !== continentMap[masterTile]) {
                     isSeparated = true;
                 }
            }

            // æµ·ã‚’éš”ã¦ã¦ã„ã‚‹å ´åˆã€ç‹¬ç«‹ç¢ºç‡ãŒå¤§å¹…ã«ä¸Šæ˜‡ã—ã€å®—ä¸»å›½ã®å®‰å®šåº¦æ¡ä»¶ãŒç·©å’Œã•ã‚Œã‚‹
            let independenceThreshold = isSeparated ? 60 : 30; // å®—ä¸»å›½ã®å®‰å®šåº¦ãŒ60æœªæº€ã§ã‚‚ç‹¬ç«‹ãƒãƒ£ãƒ³ã‚¹
            let chance = isSeparated ? 0.02 : 0.005;

            if (n.stability > 70 && master.stability < independenceThreshold && Math.random() < chance) {
                declareIndependence(n);
            }
        }
    }

    // æŒ‡å°è€…ã®äº¤ä»£
    if (Math.random() < 0.005) {
        const oldLeader = n.leader;
        n.leader = n.generateLeaderName();
        let stabChange = Math.floor(Math.random() * 30) - 20; // -20 to +10
        // å¤§çµ±é ˜åˆ¶ã¯æŒ‡å°è€…äº¤ä»£æ™‚ã®å®‰å®šåº¦ä½ä¸‹ãŒå¤§ãã„
        if (n.sysDetailed === "å¤§çµ±é ˜åˆ¶") {
            stabChange -= 15;
        }
        n.stability = clamp(n.stability + stabChange, 0, 100);
        log(`${n.name}ã®æŒ‡å°è€…ãŒ${oldLeader}ã‹ã‚‰${n.leader}ã«äº¤ä»£ã—ã¾ã—ãŸã€‚(å®‰å®šåº¦: ${stabChange > 0 ? "+" : ""}${stabChange})`, "log-info");
        n.addHistory(`æŒ‡å°è€…äº¤ä»£: ${oldLeader} -> ${n.leader}`);

        // Grand Empire Succession Crisis
        if (n.isGrandEmpire && n.cities.length >= 2 && Math.random() < 0.8) {
            triggerSuccessionCivilWar(n);
        }
    }

    // ç‹æ”¿å›½å®¶å‘ã‘ã®ãƒ©ãƒ³ãƒ€ãƒ ã‚¤ãƒ™ãƒ³ãƒˆ (å…±å’Œæ´¾ã®å°é ­ãªã©)
    if ((n.sysDetailed.includes('å›ä¸»') || n.sovereign === 'å›ä¸»') && Math.random() < 0.002) {
        const events = [
            { msg: "å…±å’Œæ´¾ã®æ´»å‹•ãŒæ´»ç™ºåŒ–ã—ã¦ã„ã¾ã™ã€‚", stab: -15 },
            { msg: "å•“è’™æ€æƒ³ãŒåºƒã¾ã‚Šã€æ—§ä½“åˆ¶ã¸ã®ä¸æº€ãŒé«˜ã¾ã£ã¦ã„ã¾ã™ã€‚", stab: -10 },
            { msg: "å®®å»·å†…ã§ã®æ¨©åŠ›äº‰ã„ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚", stab: -12 }
        ];
        const event = events[Math.floor(Math.random() * events.length)];
        n.stability = clamp(n.stability + event.stab, 0, 100);
        log(`${n.name}: ${event.msg} (å®‰å®šåº¦: ${event.stab})`, "log-war");
    }

    // å®‰å®šåº¦ã®è‡ªç„¶å¤‰å‹•
    if (n.atWarWith.length > 0) {
        // æ°‘ä¸»ä¸»ç¾©ã¯æˆ¦äº‰ç–²å¼ŠãŒå°‘ãªã„
        const stabLoss = (n.sysBroad === 'æ°‘ä¸»ä¸»ç¾©') ? 0.2 : 0.4;
        n.stability -= stabLoss;
    } else {
        n.stability = Math.min(100, n.stability + 0.5);
    }

    // ä¸æº€åº¦ã®æ›´æ–°
    // çµ±æ²»å®‰å®šåº¦(Governance)ãŒä¸æº€ã‚’ç·©å’Œã™ã‚‹
    n.unrest = Math.max(0, 100 - n.stability - (n.governance / 2));

    // éƒ½å¸‚ã”ã¨ã®ä¸æº€åº¦æ›´æ–°
    n.cities.forEach((city, idx) => {
        let cityUnrest = n.unrest + (Math.random() * 20 - 10);
        // é¦–éƒ½(index 0)ã‹ã‚‰ã®è·é›¢ã«ã‚ˆã‚‹ä¸æº€åº¦å¢—åŠ 
        if (idx > 0) {
            const capital = n.cities[0];
            const dx = (city.tileIdx % width) - (capital.tileIdx % width);
            const dy = Math.floor(city.tileIdx / width) - Math.floor(capital.tileIdx / width);
            const dist = Math.sqrt(dx*dx + dy*dy);
            cityUnrest += dist / 5;

            // æµ·ã‚’éš”ã¦ã¦ã„ã‚‹å ´åˆã®ãƒšãƒŠãƒ«ãƒ†ã‚£ (éå¸¸ã«å¤§ãã„)
            if (continentMap[city.tileIdx] !== -1 && continentMap[capital.tileIdx] !== -1 && continentMap[city.tileIdx] !== continentMap[capital.tileIdx]) {
                cityUnrest += 25; 
            }
        }
        city.unrest = clamp(cityUnrest, 0, 100);
    });

    // åä¹±ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã®æ¶ˆåŒ–
    if (n.rebellionCooldown > 0) n.rebellionCooldown--;

    // éƒ½å¸‚å˜ä½ã®å†…æˆ¦åˆ¤å®š
    let rebellingCities = [];
    if (n.rebellionCooldown === 0 && n.cities.length > 0) {
        n.cities.forEach(city => {
            // å…±å’Œåˆ¶(æ°‘ä¸»ä¸»ç¾©)ã®å›½ã¯åä¹±ç¢ºç‡ã‚’æ¥µç«¯ã«ä¸‹ã’ã‚‹ (0.005 -> 0.00005)
            // ã¾ãŸã€å¿…è¦ãªä¸æº€åº¦ã‚‚å¼•ãä¸Šã’ã‚‹ (75 -> 90)
            let rebelChance = (n.sysBroad === 'æ°‘ä¸»ä¸»ç¾©') ? 0.00005 : 0.005;
            let unrestThreshold = (n.sysBroad === 'æ°‘ä¸»ä¸»ç¾©') ? 90 : 75;

            if (city.unrest > unrestThreshold && Math.random() < rebelChance) {
                rebellingCities.push(city);
            }
        });
    }

    if (rebellingCities.length > 0) {
        // å‘¨å›²ã®ä¸æº€ãŒé«˜ã„éƒ½å¸‚ã‚‚èª˜ã„è¾¼ã‚€
        n.cities.forEach(city => {
            if (!rebellingCities.includes(city) && city.unrest > 50) {
                let isNear = rebellingCities.some(rc => {
                    const dx = (city.tileIdx % width) - (rc.tileIdx % width);
                    const dy = Math.floor(city.tileIdx / width) - Math.floor(rc.tileIdx / width);
                    return Math.sqrt(dx*dx + dy*dy) < 30;
                });
                if (isNear && Math.random() < 0.5) rebellingCities.push(city);
            }
        });
        triggerCityRebellion(n, rebellingCities);
    }

    // æ”¿å¤‰ã®åˆ¤å®š
    const coupThreshold = (n.sysBroad === 'æ°‘ä¸»ä¸»ç¾©') ? 40 : 50; // æ°‘ä¸»åˆ¶ã¯å´©å£Šã—ã«ãã„
    const coupChance = (n.sysBroad === 'æ°‘ä¸»ä¸»ç¾©') ? 0.0005 : 0.002;

    if (n.stability < coupThreshold && Math.random() < coupChance) {
        const oldName = n.name;
        const oldGov = n.sysDetailed;
        
        // æ¨©å¨ä¸»ç¾©ã¾ãŸã¯è»äº‹æ”¿æ¨©ã¸ç§»è¡Œ
        n.sysBroad = 'æ¨©å¨ä¸»ç¾©';
        n.sysDetailed = (Math.random() > 0.5) ? "å€‹äººç‹¬è£åˆ¶" : "è»äº‹è©•è­°ä¼šåˆ¶";
        n.sovereign = (n.sysDetailed === 'è»äº‹è©•è­°ä¼šåˆ¶') ? 'è»éƒ¨' : 'ç‹¬è£è€…';
        n.govType = n.sysDetailed;

        n.updateName();
        n.stability = Math.max(0, n.stability - 30);
        log(`${oldName}ã§æ”¿å¤‰ãŒç™ºç”Ÿï¼ ${oldGov}ã‹ã‚‰${n.sysDetailed}ã¸ä½“åˆ¶ãŒå¤‰ã‚ã‚Šã€${n.name}ã¨ãªã‚Šã¾ã—ãŸã€‚`, "log-war");
        n.addHistory(`æ”¿å¤‰: ${oldGov} -> ${n.sysDetailed} (${oldName} -> ${n.name})`);
    }

    // æ°‘ä¸»åˆ¶ã¸ã®ç§»è¡Œ
    if (n.sysBroad !== 'æ°‘ä¸»ä¸»ç¾©' && n.tech >= 3 && n.stability > 80 && Math.random() < 0.001) {
        const oldName = n.name;
        
        n.sysBroad = 'æ°‘ä¸»ä¸»ç¾©';
        n.sysDetailed = (Math.random() < 0.5) ? "è­°é™¢å†…é–£åˆ¶" : "å¤§çµ±é ˜åˆ¶";
        n.sovereign = 'å›½æ°‘';
        n.ecoIdeology = (Math.random() < 0.5) ? 'è‡ªç”±æ”¾ä»»ä¸»ç¾©' : 'æ··åˆçµŒæ¸ˆ';
        n.govType = n.sysDetailed;

        n.regimeNumber++;
        n.updateName();
        log(`${oldName}ã¯è¿‘ä»£åŒ–ã«ä¼´ã„æ°‘ä¸»åŒ–ã—ã€${n.name}ã¨ãªã‚Šã¾ã—ãŸã€‚`, "log-peace");
        n.addHistory(`æ°‘ä¸»åŒ–: ${oldName} -> ${n.name}`);
    }

    // å¹³å’Œçš„ç‹¬ç«‹ (ä½ç¢ºç‡)
    if (n.stability < 60 && n.cities.length > 2) {
        // é¦–éƒ½ä»¥å¤–ã§ä¸æº€ãŒé«˜ã„éƒ½å¸‚ãŒå¯¾è±¡
        const potentialCities = n.cities.filter((c, i) => i > 0 && c.unrest > 80);
        potentialCities.forEach(city => {
            if (Math.random() < 0.001) { // éå¸¸ã«ä½ç¢ºç‡
                grantIndependence(n, city);
            }
        });
    }

    // åä¹±è»ã®æ­£çµ±åŒ–
    if (n.isRebel && n.stability > 70 && n.tiles.length > 25 && Math.random() < 0.01) {
        n.isRebel = false;
        const oldName = n.name;
        
        // ã‚·ã‚¹ãƒ†ãƒ ã‚’å†æ§‹ç¯‰
        const system = generatePoliticalSystem(n.tech);
        n.sysBroad = system.sysBroad;
        n.sysDetailed = system.sysDetailed;
        n.sovereign = system.sovereign;
        n.stateStruct = system.stateStruct;
        n.ecoIdeology = system.ecoIdeology;
        n.govType = n.sysDetailed;

        n.updateName();
        log(`${oldName}ã¯å®‰å®šã—ãŸçµ±æ²»ã‚’ç¢ºç«‹ã—ã€${n.name}ã¨ã—ã¦å›½å®¶ã®æ­£çµ±æ€§ã‚’ä¸»å¼µã—å§‹ã‚ã¾ã—ãŸã€‚`, "log-peace");
        n.addHistory(`æ­£çµ±åŒ–: ${oldName} -> ${n.name}`);
    }

    // è¿½ã„è©°ã‚ã‚‰ã‚ŒãŸå®—ä¸»å›½ã«ã‚ˆã‚‹ç·Šæ€¥ä½µåˆ (ç”Ÿå­˜æˆ¦ç•¥)
    if (!n.isPuppet && (n.tiles.length < 15 || n.cities.length === 0) && !n.isDead) {
        const myPuppet = nations.find(p => p.isPuppet && p.masterId === n.id && !p.isDead);
        if (myPuppet) {
            // å…¨åœŸä½µåˆ
            log(`ç·Šæ€¥äº‹æ…‹: è¿½ã„è©°ã‚ã‚‰ã‚ŒãŸ${n.name}ã¯ã€å›½å®¶å­˜ç¶šã®ãŸã‚ã«å‚€å„¡å›½ã§ã‚ã‚‹${myPuppet.name}ã‚’ç·Šæ€¥ä½µåˆã—ã¾ã—ãŸï¼`, "log-war");
            n.addHistory(`ç·Šæ€¥ä½µåˆ: ${myPuppet.name}ã‚’ä½µåˆ`);
            
            // ã‚¿ã‚¤ãƒ«ã®ç§»å‹•
            const puppetTiles = [...myPuppet.tiles];
            puppetTiles.forEach(tileIdx => {
                ownerGrid[tileIdx] = n.id;
                n.tiles.push(tileIdx);
            });
            myPuppet.tiles = [];

            // éƒ½å¸‚ã®ç§»å‹•
            myPuppet.cities.forEach(city => {
                city.nationId = n.id;
                n.cities.push(city);
            });
            myPuppet.cities = [];

            // å‚€å„¡å›½æ¶ˆæ»…
            myPuppet.isDead = true;
            myPuppet.pop = 0; // äººå£ã‚‚å¸åã™ã¹ãã ãŒç°¡æ˜“çš„ã«0ã«
            
            // å®‰å®šåº¦å›å¾©
            n.stability = Math.min(100, n.stability + 30);
        }
    }
}

function declareIndependence(n) {
    if (!n.isPuppet) return;
    
    const oldName = n.name;
    const oldMasterId = n.masterId;
    
    n.isPuppet = false;
    n.masterId = -1;
    n.updateName();
    
    const master = nations.find(m => m.id === oldMasterId);
    if (master && !master.isDead) {
        log(`ç‹¬ç«‹å®£è¨€: ${oldName}ã¯${master.name}ã‹ã‚‰ã®ç‹¬ç«‹ã‚’å®£è¨€ã—ã€${n.name}ã¨ãªã‚Šã¾ã—ãŸã€‚`, "log-peace");
        master.addHistory(`ç‹¬ç«‹: ${n.name}ãŒç‹¬ç«‹`);
        n.addHistory(`ç‹¬ç«‹: ${master.name}ã‚ˆã‚Šç‹¬ç«‹`);
        
        // å®—ä¸»å›½ã¨ã®é–¢ä¿‚æ‚ªåŒ–
        if (master.relations[n.id] !== undefined) master.relations[n.id] -= 50;
        else master.relations[n.id] = -50;
        
        if (n.relations[master.id] !== undefined) n.relations[master.id] -= 50;
        else n.relations[master.id] = -50;
        
        // å®‰å®šåº¦ä¸Šæ˜‡ (ç‹¬ç«‹ã®é«˜æšæ„Ÿ)
        n.stability = Math.min(100, n.stability + 10);
    } else {
        log(`ç‹¬ç«‹å›å¾©: å®—ä¸»å›½ã®æ¶ˆæ»…ã¾ãŸã¯ä¸åœ¨ã«ä¼´ã„ã€${oldName}ã¯${n.name}ã¨ã—ã¦ä¸»æ¨©ã‚’å›å¾©ã—ã¾ã—ãŸã€‚`, "log-peace");
        n.addHistory(`ä¸»æ¨©å›å¾©: å®—ä¸»å›½æ¶ˆæ»…ã«ã‚ˆã‚‹`);
    }
}

function grantIndependence(n, city) {
    const newNation = new Nation();
    newNation.baseName = n.baseName;
    
    // éƒ½å¸‚åã‚’å† ã—ãŸå›½å
    const prefix = city.name.substring(0, city.name.length - 1); // "å¸‚"ãªã©ã‚’å–ã‚‹
    let proposedName = prefix + "å…±å’Œå›½";
    
    // Ensure uniqueness
    if (isNationNameTaken(proposedName)) {
        // proposedName is always "XXXå…±å’Œå›½" here, so we use Nth regime format
        let counter = 2;
        let finalName = proposedName;
        while(true) {
            let nextName = proposedName + "ç¬¬" + counter + "æ”¿";
            if (!isNationNameTaken(nextName)) {
                finalName = nextName;
                break;
            }
            counter++;
            if (counter > 100) break;
        }
        newNation.name = finalName;
    } else {
        newNation.name = proposedName;
    }

    const system = generatePoliticalSystem(n.tech);
    newNation.sysBroad = 'æ°‘ä¸»ä¸»ç¾©';
    newNation.sysDetailed = 'è­°é™¢å†…é–£åˆ¶';
    newNation.sovereign = 'å›½æ°‘';
    newNation.stateStruct = 'å˜ä¸€å›½å®¶';
    newNation.ecoIdeology = n.ecoIdeology;
    newNation.govType = newNation.sysDetailed;
    
    newNation.color = `hsl(${Math.random()*360}, 60%, 60%)`;
    newNation.tech = n.tech;
    newNation.religion = n.religion;

    // é ˜åœŸã¨éƒ½å¸‚ã®å§”è­²
    const radius = 6;
    const cx = city.tileIdx % width;
    const cy = Math.floor(city.tileIdx / width);
    
    for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
            const nx = cx + dx;
            const ny = cy + dy;
            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                const idx = ny * width + nx;
                if (ownerGrid[idx] === n.id) {
                    ownerGrid[idx] = newNation.id;
                    newNation.tiles.push(idx);
                    n.tiles = n.tiles.filter(t => t !== idx);
                }
            }
        }
    }
    
    city.nationId = newNation.id;
    newNation.cities.push(city);
    n.cities = n.cities.filter(c => c !== city);

    // äººå£ãƒ»å…µåŠ›ã®åˆ†é…
    const ratio = 1 / (n.cities.length + 1); // ç°¡æ˜“è¨ˆç®—
    newNation.pop = Math.floor(n.pop * ratio);
    n.pop = Math.max(0, n.pop - newNation.pop);
    newNation.soldiers = Math.floor(n.soldiers * ratio * 0.5); // å…µåŠ›ã¯å°‘ãªã‚
    n.soldiers = Math.max(0, n.soldiers - newNation.soldiers);

    if (newNation.tiles.length > 0) {
        nations.push(newNation);
        
        // è‰¯å¥½ãªé–¢ä¿‚ã§ã‚¹ã‚¿ãƒ¼ãƒˆ
        n.relations[newNation.id] = 50;
        newNation.relations[n.id] = 50;
        
        log(`å¹³å’Œçš„ç‹¬ç«‹: ${n.name}ã‹ã‚‰${city.name}ãŒåˆ†é›¢ã—ã€${newNation.name}ã¨ã—ã¦ç‹¬ç«‹ã—ã¾ã—ãŸã€‚`, "log-peace");
        n.addHistory(`ç‹¬ç«‹æ‰¿èª: ${newNation.name}`);
        newNation.addHistory(`ç‹¬ç«‹: ${n.name}ã‹ã‚‰åˆ†é›¢ç‹¬ç«‹`);
        
        // å®‰å®šåº¦å°‘ã—å›å¾©ï¼ˆå„ä»‹æ‰•ã„ãŒã§ããŸãŸã‚ï¼‰
        n.stability = Math.min(100, n.stability + 5);
    }
}

function triggerCityRebellion(n, cities) {
    // åä¹±è»ã®ç”Ÿæˆ
    const rebel = new Nation();
    rebel.baseName = n.baseName;
    rebel.parentName = n.baseName;
    rebel.isRebel = true;

    // åä¹±è»ã®æ”¿æ²»ä½“åˆ¶
    rebel.ecoIdeology = n.ecoIdeology;
    rebel.stateStruct = 'å˜ä¸€å›½å®¶';

    if (n.sysBroad === 'æ°‘ä¸»ä¸»ç¾©') {
         // æ°‘ä¸»åˆ¶ã‹ã‚‰ã®åä¹± -> è»äº‹ã‚¯ãƒ¼ãƒ‡ã‚¿ãƒ¼ã‚„é©å‘½
         rebel.sysBroad = 'æ¨©å¨ä¸»ç¾©';
         rebel.sysDetailed = 'è»äº‹è©•è­°ä¼šåˆ¶';
         rebel.sovereign = 'è»éƒ¨';
    } else {
         // æ¨©å¨ä¸»ç¾©ã‹ã‚‰ã®åä¹± -> æ°‘ä¸»åŒ–é©å‘½
         rebel.sysBroad = 'æ°‘ä¸»ä¸»ç¾©';
         rebel.sysDetailed = 'é©å‘½æ”¿åºœ';
         rebel.sovereign = 'å›½æ°‘';
    }
    rebel.govType = rebel.sysDetailed;

    // ã‹ã£ã“ã„ã„åä¹±è»ã®åç§°ç”Ÿæˆ
    const rebelTypes = [
        { name: "è‡¨æ™‚æ”¿åºœ", gov: "è‡¨æ™‚æ”¿åºœ" },
        { name: "ç«‹æ†²æ´¾", gov: "é©å‘½æ”¿åºœ" },
        { name: "æ­£çµ±æ”¿åºœ", gov: "æ­£çµ±æ”¿åºœ" },
        { name: "æ•‘å›½æˆ¦ç·š", gov: "è»äº‹è©•è­°ä¼šåˆ¶" },
        { name: "äººæ°‘å§”å“¡ä¼š", gov: "é©å‘½æ”¿åºœ" }
    ];
    
    // ç‰¹åˆ¥ãªåç§°: å…±å’Œå›½ç¬¬næ”¿ (è¦ªãŒæ°‘ä¸»åˆ¶ã®å ´åˆ)
    if (n.sysBroad === 'æ°‘ä¸»ä¸»ç¾©' && Math.random() < 0.4) {
        rebel.sysBroad = 'æ°‘ä¸»ä¸»ç¾©';
        rebel.sysDetailed = n.sysDetailed;
        rebel.sovereign = 'å›½æ°‘';
        rebel.regimeNumber = n.regimeNumber + 1;
        rebel.govType = rebel.sysDetailed;
        rebel.updateName();
    } else {
        const type = rebelTypes[Math.floor(Math.random() * rebelTypes.length)];
        rebel.sysDetailed = type.gov;
        // Adjust broad/sovereign for special types
        if (type.gov === 'é©å‘½æ”¿åºœ' || type.gov === 'è‡¨æ™‚æ”¿åºœ') {
            rebel.sysBroad = 'æ°‘ä¸»ä¸»ç¾©';
            rebel.sovereign = 'å›½æ°‘';
        } else if (type.gov === 'è»äº‹è©•è­°ä¼šåˆ¶') {
            rebel.sysBroad = 'æ¨©å¨ä¸»ç¾©';
            rebel.sovereign = 'è»éƒ¨';
        } else if (type.gov === 'æ­£çµ±æ”¿åºœ') {
            rebel.sysBroad = n.sysBroad;
            rebel.sovereign = n.sovereign;
        }
        rebel.govType = rebel.sysDetailed;

        // éƒ½å¸‚åã‚’å† ã—ãŸåç§°ã«ã™ã‚‹ (æœ€åˆã®éƒ½å¸‚)
        const prefix = cities[0].name.substring(0, cities[0].name.length - 1);
        let proposedName = prefix + type.name;

        // Ensure uniqueness
        if (isNationNameTaken(proposedName, rebel.id)) {
            let counter = 2;
            let finalName = proposedName;
            while(true) {
                let nextName = proposedName + " (" + counter + ")";
                if (!isNationNameTaken(nextName, rebel.id)) {
                    finalName = nextName;
                    break;
                }
                counter++;
                if (counter > 100) break;
            }
            rebel.name = finalName;
        } else {
            rebel.name = proposedName;
        }
    }

    rebel.rebellionCooldown = 200; // åˆæœŸç„¡æ•µçŠ¶æ…‹
    n.rebellionCooldown = 200; // è¦ªå›½ã‚‚ä¸€å®šæœŸé–“å†ç™ºé˜²æ­¢
    rebel.color = `hsl(${Math.random()*360}, 80%, 40%)`;
    rebel.tech = n.tech;
    rebel.religion = n.religion;
    
    // é ˜åœŸã¨éƒ½å¸‚ã®å§”è­²
    cities.forEach(city => {
        const cityIdx = city.tileIdx;
        const cx = cityIdx % width;
        const cy = Math.floor(cityIdx / width);
        const radius = 6;
        
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const nx = cx + dx;
                const ny = cy + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    const idx = ny * width + nx;
                    if (ownerGrid[idx] === n.id) {
                        ownerGrid[idx] = rebel.id;
                        rebel.tiles.push(idx);
                        n.tiles = n.tiles.filter(t => t !== idx);
                    }
                }
            }
        }
        city.nationId = rebel.id;
        rebel.cities.push(city);
    });
    n.cities = n.cities.filter(c => !cities.includes(c));

    // å…µåŠ›ã¨äººå£ã®åˆ†é…
    const ratio = cities.length / (n.cities.length + cities.length);
    rebel.pop = Math.floor(n.pop * ratio);
    n.pop = Math.floor(n.pop - rebel.pop);
    rebel.soldiers = Math.floor(n.soldiers * ratio * 0.8);
    n.soldiers = Math.floor(n.soldiers - rebel.soldiers);

    if (rebel.tiles.length > 0) {
        nations.push(rebel);
        declareWar(n, rebel);
        log(`${n.name}ã§å†…æˆ¦ãŒç™ºç”Ÿï¼ ${cities.map(c => c.name).join('ã€')}ãŒ${rebel.name}ã¨ã—ã¦èœ‚èµ·ã—ã¾ã—ãŸã€‚`, "log-war");
        n.addHistory(`å†…æˆ¦å‹ƒç™º: ${rebel.name}ãŒèœ‚èµ·`);
        rebel.addHistory(`èœ‚èµ·: ${n.name}ã«å¯¾ã—åä¹±ã‚’é–‹å§‹`);
        n.stability = Math.max(0, n.stability - 20);
    }
}

function triggerSuccessionCivilWar(n) {
    // Create the pretender nation
    const rebel = new Nation();
    rebel.baseName = n.baseName;
    rebel.isRebel = false; // Claims to be legitimate
    
    rebel.isGrandEmpire = true;
    rebel.sysBroad = n.sysBroad;
    rebel.sysDetailed = n.sysDetailed;
    rebel.sovereign = n.sovereign;
    rebel.stateStruct = n.stateStruct;
    rebel.ecoIdeology = n.ecoIdeology;
    rebel.govType = n.govType;
    rebel.tech = n.tech;
    rebel.religion = n.religion;
    rebel.color = `hsl(${Math.random()*360}, 100%, 30%)`; // Another dark color
    
    // Name handling - collision logic will handle uniqueness
    rebel.updateName();
    
    if (n.cities.length < 2) return; // Cannot split if limited cities
    
    // Pick a second capital (furthest from current capital)
    const capital = n.cities[0];
    let bestCity = null;
    let maxDist = -1;
    
    n.cities.forEach(c => {
        if (c === capital) return;
        const dist = getDistSq(c.tileIdx, capital.tileIdx);
        if (dist > maxDist) {
            maxDist = dist;
            bestCity = c;
        }
    });
    
    if (!bestCity) return;
    
    // Assign cities closer to rebel capital to rebel
    const rebelCities = [];
    const loyalCities = [capital];
    
    n.cities.forEach(c => {
        if (c === capital || c === bestCity) return;
        
        const d1 = getDistSq(c.tileIdx, capital.tileIdx);
        const d2 = getDistSq(c.tileIdx, bestCity.tileIdx);
        
        if (d2 < d1) rebelCities.push(c);
        else loyalCities.push(c);
    });
    rebelCities.push(bestCity);
    
    // Transfer cities
    rebelCities.forEach(c => {
        c.nationId = rebel.id;
        rebel.cities.push(c);
    });
    n.cities = loyalCities;
    
    // Transfer tiles (Voronoi split)
    const capX = capital.tileIdx % width;
    const capY = Math.floor(capital.tileIdx / width);
    const rebX = bestCity.tileIdx % width;
    const rebY = Math.floor(bestCity.tileIdx / width);
    
    const newNTiles = [];
    n.tiles.forEach(tIdx => {
        const tx = tIdx % width;
        const ty = Math.floor(tIdx / width);
        const d1 = (tx-capX)**2 + (ty-capY)**2;
        const d2 = (tx-rebX)**2 + (ty-rebY)**2;
        
        if (d2 < d1) {
            ownerGrid[tIdx] = rebel.id;
            rebel.tiles.push(tIdx);
        } else {
            newNTiles.push(tIdx);
        }
    });
    n.tiles = newNTiles;
    
    // Distribute Stats
    const ratio = rebel.tiles.length / (rebel.tiles.length + n.tiles.length);
    
    rebel.pop = Math.floor(n.pop * ratio);
    n.pop = Math.floor(n.pop - rebel.pop);
    
    rebel.soldiers = Math.floor(n.soldiers * ratio);
    n.soldiers = Math.floor(n.soldiers - rebel.soldiers);
    
    rebel.gdp = Math.floor(n.gdp * ratio);
    n.gdp = Math.floor(n.gdp - rebel.gdp);
    
    // Push to nations array
    if (rebel.tiles.length > 0) {
        nations.push(rebel);
        rebel.updateCentroid();
        n.updateCentroid();
        
        // War
        declareWar(n, rebel);
        
        // Log
        log(`å¸ä½ç¶™æ‰¿æˆ¦äº‰: ${n.name}ã®çš‡å¸å´©å¾¡ã«ä¼´ã„ã€å›½ãŒäºŒã¤ã«å‰²ã‚Œã¾ã—ãŸï¼åŒæ–¹ãŒæ­£çµ±æ€§ã‚’ä¸»å¼µã—ã¦ã„ã¾ã™ã€‚`, "log-war");
        n.addHistory(`å†…æˆ¦å‹ƒç™º: å¸ä½ç¶™æ‰¿æˆ¦äº‰`);
        rebel.addHistory(`å†…æˆ¦å‹ƒç™º: å¸ä½ç¶™æ‰¿æˆ¦äº‰`);
        
        // Reduce stability significantly
        n.stability = 30;
        rebel.stability = 30;
    }
}

function getDistSq(idx1, idx2) {
    const x1 = idx1 % width;
    const y1 = Math.floor(idx1 / width);
    const x2 = idx2 % width;
    const y2 = Math.floor(idx2 / width);
    return (x1-x2)**2 + (y1-y2)**2;
}

function simulateTick() {
    if (mapDirty) {
        updateContinents();
        mapDirty = false;
    }

    let totalPop = 0;
    let totalLandTiles = 0;
    for(let i=0; i<grid.length; i++) if(grid[i] !== 0) totalLandTiles++;

    // ç·Šå¼µæ„Ÿã®è‡ªç„¶æ¸›è¡°
    worldTension = Math.max(0, worldTension - 0.2);

    // 1. å†…æ”¿ãƒ•ã‚§ãƒ¼ã‚º
    nations.forEach(n => {
        if (n.isDead) return;
        
        handlePolitics(n);

        // æœªé–‹æ‹“åœ°ã®æ¤æ°‘
        if (Math.random() < 0.05) { // 5% chance per tick
            // ãƒ©ãƒ³ãƒ€ãƒ ã«é ˜åœŸã‚’ãƒ”ãƒƒã‚¯ã—ã¦ã€éš£æ¥ã™ã‚‹æœªé–‹æ‹“åœ°(ownerGrid == -1)ã‚’æ¢ã™
            const sampleTiles = [];
            for(let i=0; i<10; i++) {
                if (n.tiles.length > 0) {
                    sampleTiles.push(n.tiles[Math.floor(Math.random() * n.tiles.length)]);
                }
            }
            
            for(const tIdx of sampleTiles) {
                const cx = tIdx % width;
                const cy = Math.floor(tIdx / width);
                let done = false;
                
                const neighbors = [[0,1],[0,-1],[1,0],[-1,0]];
                // ãƒ©ãƒ³ãƒ€ãƒ ãªé †åºã§è©¦ã™
                neighbors.sort(() => Math.random() - 0.5);

                for(const [dx, dy] of neighbors) {
                    let nx=cx+dx, ny=cy+dy;
                    if(nx>=0 && nx<width && ny>=0 && ny<height) {
                        let nIdx = ny*width+nx;
                        if(ownerGrid[nIdx] === -1 && grid[nIdx] === 1) { // æœªæ‰€å±ã®é™¸åœ°
                            ownerGrid[nIdx] = n.id;
                            n.tiles.push(nIdx);
                            // ã‚³ã‚¹ãƒˆ
                            n.gdp = Math.max(0, n.gdp - 5);
                            done = true;
                            break;
                        }
                    }
                }
                if(done) break;
            }
        }

        // éƒ½å¸‚ã®å»ºè¨­
        if (n.tiles.length > (n.cities.length + 1) * 50 && Math.random() < 0.05) {
            const potentialTiles = n.tiles.filter(t => !n.cities.some(c => c.tileIdx === t));
            if (potentialTiles.length > 0) {
                const newTile = potentialTiles[Math.floor(Math.random() * potentialTiles.length)];
                const cityName = n.generateCityName();
                n.cities.push(new City(cityName, newTile, n.id));
                log(`${n.name}ãŒæ–°ãŸãªéƒ½å¸‚ã€Œ${cityName}ã€ã‚’å»ºè¨­ã—ã¾ã—ãŸã€‚`, "log-info");
            }
        }

        // äººå£å¢—åŠ : é ˜åœŸé¢ç©ã¨æŠ€è¡“ã«åŸºã¥ããƒ­ã‚¸ã‚¹ãƒ†ã‚£ãƒƒã‚¯å›å¸°ãƒ¢ãƒ‡ãƒ«
        let capacity = n.tiles.length * 1000 * (1 + n.tech * 0.5);
        let growth = 0.02 * (1 - n.pop / capacity);
        if (growth < -0.01) growth = -0.01; // æ€¥æ¿€ãªæ¸›å°‘ã‚’æŠ‘ãˆã‚‹
        n.pop = Math.floor(n.pop * (1 + growth));
        
        // GDPæˆé•·: å·¥æ¥­åŠ›ã¨äººå£ã€æŠ€è¡“ï¼ˆäººå£ä¾å­˜åº¦ã‚’ä¸‹ã’ã‚‹ï¼‰
        n.gdp += (n.industry * 2) + (n.pop * 0.002) * (1 + n.tech);
        
        // è»å‚™å¢—å¼·: GDPã®ä¸€éƒ¨ã‚’è»äº‹è²»ã¸
        let milBudget = n.gdp * 0.1;
        if (n.atWarWith.length > 0) milBudget = n.gdp * 0.3; // æˆ¦æ™‚ä½“åˆ¶

        // å…µå£«é›‡ç”¨ / ç¶­æŒ
        let desiredSoldiers = Math.floor(n.pop * 0.05); // äººå£ã®5%ãŒä¸Šé™ç›®å®‰
        if (n.soldiers < desiredSoldiers && milBudget > 0) {
            n.soldiers += 10;
            milBudget -= 10;
        }
        
        // æŠ€è¡“ç™ºå±• / æˆ¦è»Šè£½é€ 
        if (n.gdp > 5000 && n.tech < 4 && Math.random() < 0.01) n.tech++;
        if (n.tech >= 2 && milBudget > 100) {
            n.tanks++;
            milBudget -= 50;
        }
        
        // æµ·è»å»ºé€  (æŠ€è¡“ãƒ¬ãƒ™ãƒ«2ä»¥ä¸Šã‹ã¤æµ·å²¸ç·šãŒã‚ã‚‹å ´åˆ)
        if (n.tech >= 2 && milBudget > 150 && n.isCoastal()) {
            n.ships++;
            milBudget -= 100;
        }

        // é‡å¿ƒè¨ˆç®—
        n.updateCentroid();

        totalPop += n.pop;
    });
    document.getElementById('info-pop').innerText = formatNum(totalPop);

    // 2. å¤–äº¤ãƒ•ã‚§ãƒ¼ã‚º
    hegemonId = -1;
    let maxScore = -1;
    nations.forEach(n => {
        if (!n.isDead) {
            // Score = GDP + (Pop/100) + (Mil*10) + (Tiles*50)
            const score = n.gdp + (n.pop / 100) + (n.getMilitaryPower() * 10) + (n.tiles.length * 50);
            if (score > maxScore) {
                maxScore = score;
                hegemonId = n.id;
            }
        }
    });

    hegemonStatus = "";
    if (hegemonId !== -1) {
        const h = nations.find(n => n.id === hegemonId);
        if (h && totalLandTiles > 0) {
             const ratio = h.tiles.length / totalLandTiles;
             if (ratio >= 0.66) hegemonStatus = "ç§©åºç¶­æŒå›½";
             else if (ratio >= 0.40) hegemonStatus = "ä¸–ç•Œè¦‡æ¨©å›½";
             else if (ratio >= 0.15) hegemonStatus = "åœ°åŸŸè¦‡æ¨©å›½";
             else hegemonStatus = "åˆ—å¼·";
        } else {
             hegemonStatus = "åˆ—å¼·";
        }
    }

    nations.forEach(n => {
        if (n.isDead) return;

        // è¦‡æ¨©å›½ï¼ˆç§©åºç¶­æŒå›½ï¼‰ã®å ´åˆã€ç§©åºç¶­æŒãƒ¢ãƒ¼ãƒ‰
        if (n.id === hegemonId && hegemonStatus === "ç§©åºç¶­æŒå›½") {
            // ä»–å›½ã®æˆ¦äº‰ã«ä»‹å…¥ã—ã¦åœæˆ¦ã•ã›ã‚‹ (ä»²ä»‹)
            nations.forEach(other => {
                if (other.id !== n.id && !other.isDead && other.atWarWith.length > 0) {
                    // è‡ªåˆ†ã¨ã®æˆ¦äº‰ã¯é™¤ã
                    const enemies = other.atWarWith.filter(eId => eId !== n.id);
                    enemies.forEach(eId => {
                        const enemy = nations.find(en => en.id === eId);
                        if (enemy && !enemy.isDead) {
                            // å¼·åˆ¶çš„ã«ç™½ç´™è¬›å’Œ
                            // Log only once per pair (check if they are still at war)
                            if (other.atWarWith.includes(eId)) {
                                concludePeace(other, enemy, 'WHITE_PEACE');
                                log(`ç§©åºç¶­æŒ: è¦‡æ¨©å›½${n.name}ã®ä»²ä»‹ã«ã‚ˆã‚Šã€${other.name}ã¨${enemy.name}ã¯åœæˆ¦ã—ã¾ã—ãŸã€‚`, "log-peace");
                            }
                        }
                    });
                }
            });
            
            // è¦‡æ¨©å›½ï¼ˆç§©åºç¶­æŒå›½ï¼‰ã¯è‡ªã‚‰å®£æˆ¦å¸ƒå‘Šã—ãªã„ï¼ˆåä¹±é®åœ§ãªã©ã¯é™¤ãï¼‰
            return;
        }

        // å¤–äº¤ä½µåˆ: å‚€å„¡å›½ã‚’ä½µåˆ
        if (!n.isPuppet) {
            const myPuppets = nations.filter(p => p.isPuppet && p.masterId === n.id && !p.isDead);
            myPuppets.forEach(p => {
                // 10å¹´ä»¥ä¸ŠçµŒéã‹ã¤å®—ä¸»å›½ã®å®‰å®šåº¦ãŒé«˜ã„å ´åˆ
                if (year - p.puppetSince > 10 && n.stability > 70 && Math.random() < 0.005) {
                    log(`å¤–äº¤ä½µåˆ: ${n.name}ã¯é•·å¹´ã®å±å›½ã§ã‚ã‚‹${p.name}ã‚’å®Œå…¨ã«ä½µåˆã—ã¾ã—ãŸã€‚`, "log-peace");
                    n.addHistory(`å¤–äº¤ä½µåˆ: ${p.name}ã‚’çµ±åˆ`);
                    
                    // é ˜åœŸçµ±åˆ
                    const pTiles = [...p.tiles];
                    pTiles.forEach(t => {
                        ownerGrid[t] = n.id;
                        n.tiles.push(t);
                    });
                    p.tiles = [];
                    
                    // éƒ½å¸‚çµ±åˆ
                    p.cities.forEach(c => {
                        c.nationId = n.id;
                        n.cities.push(c);
                    });
                    p.cities = [];

                    p.isDead = true;
                    p.pop = 0;
                    n.stability = Math.min(100, n.stability + 10);
                }
            });
        }
        
        // ãƒ©ãƒ³ãƒ€ãƒ ãªå¯¾è±¡å›½ã‚’é¸ã¶ (é »åº¦å‘ä¸Š)
        const target = nations[Math.floor(Math.random() * nations.length)];
        if (target.id === n.id || target.isDead) return;

        // é–¢ä¿‚å€¤åˆæœŸåŒ–
        if (n.relations[target.id] === undefined) n.relations[target.id] = 0;

        // é–¢ä¿‚å¤‰å‹•è¦å›  (ã‚ˆã‚Šéæ¿€ã«)
        let change = (Math.random() - 0.5) * 5; 
        if (n.religion === target.religion) change += 5;
        else change -= 5;
        
        // Grand Empire: Hated by everyone
        if (n.isGrandEmpire) change -= 2.0;

        // ä¸–ç•Œã®ç·Šå¼µæ„Ÿã«ã‚ˆã‚‹æ‚ªåŒ–
        change -= (worldTension / 10);
        
        // éš£æ¥ã—ã¦ã„ã‚‹ã¨æ‘©æ“¦ãŒéå¸¸ã«èµ·ãã‚„ã™ã„
        let neighbor = isNeighbor(n, target);
        if (neighbor) change -= 10;

        // ãƒœãƒ¼ãƒ€ãƒ¼ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆ (çªç™ºçš„ãªæ‚ªåŒ–)
        if (neighbor && Math.random() < 0.05) {
            change -= 40;
            log(`å¶ç™ºçš„è¡çª: ${n.name}ã¨${target.name}ã®é–“ã§ç·Šå¼µãŒé«˜ã¾ã£ã¦ã„ã¾ã™ï¼`, "log-war");
        }

        n.relations[target.id] = clamp(n.relations[target.id] + change, -100, 100);

        // æˆ¦äº‰åˆ¤å®š (é–¾å€¤ã‚’ä¸‹ã’ã€å¥½æˆ¦çš„ã«)
        // éš£æ¥ã—ã¦ã„ã‚‹ã‹ã€ã‚ã‚‹ã„ã¯æµ·è»åŠ›ãŒã‚ã‚Šä¸¡è€…ãŒæ²¿å²¸å›½ã§ã‚ã‚Œã°å®£æˆ¦å¸ƒå‘Šå¯èƒ½
        const canNavalInvade = (n.tech >= 3 && n.ships >= 20 && n.isCoastal() && target.isCoastal());

        // çµŒæ¸ˆå¤§å›½(GDP>3000ã‹ã¤è‡ªå›½ã®1.5å€ä»¥ä¸Š)ã¸ã®æ”»æ’ƒã¯ã€è»äº‹å¤§å›½(è»äº‹åŠ›1.5å€)ã‹é‡å¿ƒ(å¸å›½)ã€ã‚ã‚‹ã„ã¯æ¿€æ€’(é–¢ä¿‚<-90)ãŒå¿…è¦
        if (target.gdp > 3000 && target.gdp > n.gdp * 1.5) {
             const isMilSuper = n.getMilitaryPower() > target.getMilitaryPower() * 1.5;
             // æ”»æ’ƒå´ãŒè»äº‹å¤§å›½ã§ã‚‚ãªãã€é‡å¿ƒçš„ãªå¸å›½ã§ã‚‚ãªãã€é–¢ä¿‚ãŒæœ€æ‚ªã§ã‚‚ãªã„å ´åˆã¯æˆ¦äº‰ã‚’å›é¿
             if (!isMilSuper && !n.isGrandEmpire && n.relations[target.id] > -90) {
                 return; 
             }
        }

        // æ°‘ä¸»ä¸»ç¾©å›½åŒå£«ã®å¹³å’Œ (Democratic Peace Theory)
        // åŒæ–¹ãŒæ°‘ä¸»ä¸»ç¾©ã®å ´åˆã€ã‚ˆã»ã©ã®å¯¾ç«‹(é–¢ä¿‚<-80)ã‚„é‡å¿ƒãŒãªã„é™ã‚Šæˆ¦äº‰ã‚’å›é¿ã™ã‚‹
        if (n.sysBroad === 'æ°‘ä¸»ä¸»ç¾©' && target.sysBroad === 'æ°‘ä¸»ä¸»ç¾©') {
            if (n.relations[target.id] > -80 && !n.isGrandEmpire) {
                return;
            }
        }
        
        if (n.relations[target.id] < -50 && (neighbor || canNavalInvade)) {
            if (!n.atWarWith.includes(target.id)) {
                // å‚€å„¡å›½ã¯ä¸»äººã«é€†ã‚‰ã‚ãªã„
                if (n.isPuppet && n.masterId === target.id) return;
                // ä¸»äººã¯å‚€å„¡å›½ã‚’æ”»æ’ƒã—ãªã„
                if (target.isPuppet && target.masterId === n.id) return;
                declareWar(n, target);
            }
        }

        // é‡å¿ƒã«ã‚ˆã‚‹é–‹æˆ¦ (åœ§å€’çš„æœ‰åˆ©ãªå ´åˆ)
        let ambitionThreshold = 2.0;
        let ambitionChance = 0.05;
        if (n.isGrandEmpire) {
            ambitionThreshold = 1.2;
            ambitionChance = 0.2; // Very aggressive
        }

        if ((neighbor || canNavalInvade) && n.getMilitaryPower() > target.getMilitaryPower() * ambitionThreshold && Math.random() < ambitionChance) {
            if (!n.atWarWith.includes(target.id)) {
                // å‚€å„¡å›½ã¯ä¸»äººã«é€†ã‚‰ã‚ãªã„
                if (n.isPuppet && n.masterId === target.id) return;
                // ä¸»äººã¯å‚€å„¡å›½ã‚’æ”»æ’ƒã—ãªã„
                if (target.isPuppet && target.masterId === n.id) return;
                log(`é‡å¿ƒ: ${n.name}ã¯${target.name}ã¸ã®é ˜åœŸæ‹¡å¤§ã®å¥½æ©Ÿã‚’è¦‹å‡ºã—ã¾ã—ãŸï¼`, "log-war");
                declareWar(n, target);
            }
        }
        // å’Œå¹³åˆ¤å®š
        else if (n.atWarWith.includes(target.id)) {
            let peaceChance = 0.005; // åŸºç¤å’Œå¹³ç¢ºç‡
            if (n.relations[target.id] > -20) peaceChance += 0.02;
            
            // åœ°å½¢ã«ã‚ˆã‚‹å’Œå¹³ç¢ºç‡ã®ä¸Šæ˜‡ (å±±ã‚„å·ãŒå¢ƒç•Œã ã¨è† ç€ã—ã‚„ã™ã„)
            const comp = getBoundaryComposition(n, target);
            let roughTerrainRatio = 0;
            if (comp.total > 0) {
                roughTerrainRatio = (comp.mountain + comp.river) / comp.total;
                if (roughTerrainRatio > 0.4) {
                    peaceChance += 0.05; // å¢ƒç•Œã®40%ä»¥ä¸ŠãŒé™ºã—ã„åœ°å½¢ã§å’Œå¹³ã—ã‚„ã™ããªã‚‹
                }
            }

            if (Math.random() < peaceChance) {
                // çµ‚æˆ¦å½¢å¼ã®æ±ºå®š
                const nPow = n.getMilitaryPower();
                const tPow = target.getMilitaryPower();
                const ratio = nPow / tPow;

                if (ratio > 5 || ratio < 0.2) {
                    // ä¸€æ–¹ãŒåœ§å€’çš„
                    const loser = ratio > 5 ? target : n;
                    if (loser.stability < 40 || loser.cities.length <= 2) {
                        concludePeace(n, target, 'PUPPET');
                    } else {
                        concludePeace(n, target, 'PARTIAL_PEACE');
                    }
                } else if (ratio > 2.5 || ratio < 0.4) {
                    // å„ªå‹¢ -> å›½å¢ƒå‰²è­² ã¾ãŸã¯ éƒ½å¸‚å‰²è­²
                    if (Math.random() < 0.6) {
                        concludePeace(n, target, 'ANNEX_BORDER');
                    } else {
                        concludePeace(n, target, 'PARTIAL_PEACE');
                    }
                } else if (roughTerrainRatio > 0.6) {
                    // åœ°å½¢ã«ã‚ˆã‚‹è† ç€
                    concludePeace(n, target, 'WHITE_PEACE');
                } else {
                    concludePeace(n, target, 'DEFAULT');
                }
            }
        }
    });

    // 3. æˆ¦äº‰ãƒ•ã‚§ãƒ¼ã‚º
    nations.forEach(attacker => {
        if (attacker.isDead) return;
        
        attacker.atWarWith.forEach(enemyId => {
            const defender = nations.find(n => n.id === enemyId);
            if (!defender || defender.isDead) return;

            // æˆ¦é—˜å‡¦ç†
            if (isNeighbor(attacker, defender)) {
                battle(attacker, defender);
            } else {
                // ééš£æ¥å›½ã¸ã®ä¸Šé™¸ä½œæˆ¦
                if (attacker.tech >= 3 && Math.random() < 0.1) {
                    navalLanding(attacker, defender);
                }
            }
        });
    });
    
    // æ»…äº¡åˆ¤å®š
    nations.forEach(n => {
        if (!n.isDead && n.tiles.length === 0) {
            n.isDead = true;
            log(`${n.name}ãŒæ»…äº¡ã—ã¾ã—ãŸï¼`, "log-war");
            // æˆ¦äº‰çŠ¶æ…‹è§£é™¤
            nations.forEach(other => {
                other.atWarWith = other.atWarWith.filter(id => id !== n.id);
            });
        }
    });
}

function isNeighbor(n1, n2) {
    // é‡ã„ã®ã§ç°¡æ˜“åˆ¤å®š: é ˜åœŸã®ä¸­å¿ƒè·é›¢ãªã©ã§ã¯ãªãã€å®Ÿéš›ã®ã‚°ãƒªãƒƒãƒ‰èµ°æŸ»ã¯é‡ã™ãã‚‹ã€‚
    // ã“ã“ã§ã¯ã€Œæˆ¦äº‰ä¸­ãªã‚‰å¼·åˆ¶çš„ã«æ¥è§¦ã‚ã‚Šã¨ã¿ãªã™ã€ã¾ãŸã¯ç°¡æ˜“çš„ãªãƒ©ãƒ³ãƒ€ãƒ ãƒã‚§ãƒƒã‚¯
    // æ­£ç¢ºã«ã™ã‚‹ãªã‚‰å¢ƒç•Œç·šãƒªã‚¹ãƒˆã‚’æŒã¤ã¹ãã ãŒã€ä»Šå›ã¯ãƒ©ãƒ³ãƒ€ãƒ ãƒ”ãƒƒã‚¯ã§ä»£ç”¨
    for(let i=0; i<50; i++) {
        let tile = n1.tiles[Math.floor(Math.random() * n1.tiles.length)];
        if (tile === undefined) continue;
        let cx = tile % width;
        let cy = Math.floor(tile / width);
        let found = false;
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
            let nx=cx+dx, ny=cy+dy;
            if(nx>=0 && nx<width && ny>=0 && ny<height) {
                let nIdx = ny*width+nx;
                if(ownerGrid[nIdx] === n2.id) found = true;
            }
        });
        if(found) return true;
    }
    return false;
}

/**
 * å¢ƒç•Œç·šã®åœ°å½¢æ§‹æˆã‚’å–å¾—
 */
function getBoundaryComposition(n1, n2) {
    let counts = {mountain: 0, river: 0, total: 0};
    const samples = Math.min(n1.tiles.length, 100);
    for(let i=0; i<samples; i++) {
        let tile = n1.tiles[Math.floor(Math.random() * n1.tiles.length)];
        if (tile === undefined) continue;
        let cx = tile % width;
        let cy = Math.floor(tile / width);
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
            let nx=cx+dx, ny=cy+dy;
            if(nx>=0 && nx<width && ny>=0 && ny<height) {
                let nIdx = ny*width+nx;
                if(ownerGrid[nIdx] === n2.id) {
                    counts.total++;
                    const type = grid[nIdx];
                    if (type === 2) counts.mountain++;
                    else if (type === 3) counts.river++;
                }
            }
        });
    }
    return counts;
}

function declareWar(n1, n2) {
    if(n1.atWarWith.includes(n2.id)) return;
    n1.atWarWith.push(n2.id);
    if(!n2.atWarWith.includes(n1.id)) n2.atWarWith.push(n1.id);
    worldTension = Math.min(100, worldTension + 5);
    log(`æˆ¦äº‰: ${n1.name}ãŒ${n2.name}ã«å®£æˆ¦å¸ƒå‘Šã—ã¾ã—ãŸï¼ï¼ˆç·Šå¼µåº¦: ${worldTension.toFixed(1)}%ï¼‰`, "log-war");
    n1.addHistory(`å®£æˆ¦å¸ƒå‘Š: å¯¾${n2.name}`);
    n2.addHistory(`å®£æˆ¦å¸ƒå‘Šã•ã‚Œã‚‹: ${n1.name}ã‚ˆã‚Š`);

    // å®—ä¸»å›½ã«ã‚ˆã‚‹é˜²è¡›
    if (n2.isPuppet && n2.masterId !== -1) {
        const master = nations.find(m => m.id === n2.masterId);
        if (master && !master.isDead && master.id !== n1.id) {
            if (!master.atWarWith.includes(n1.id)) {
                 log(`${n2.name}ã®å®—ä¸»å›½ã§ã‚ã‚‹${master.name}ãŒä¿è­·ç¾©å‹™ã‚’å±¥è¡Œã—ã€å‚æˆ¦ã—ã¾ã—ãŸã€‚`, "log-war");
                 declareWar(master, n1);
            }
        }
    }

    // å‚€å„¡å›½ã‚‚å‚æˆ¦
    nations.forEach(puppet => {
        if (puppet.isPuppet && puppet.masterId === n1.id && !puppet.isDead) {
            if (!puppet.atWarWith.includes(n2.id)) {
                puppet.atWarWith.push(n2.id);
                if (!n2.atWarWith.includes(puppet.id)) n2.atWarWith.push(puppet.id);
                log(`${n1.name}ã®å‚€å„¡å›½ã€${puppet.name}ãŒå‚æˆ¦ã—ã¾ã—ãŸã€‚`, "log-war");
            }
        }
        if (puppet.isPuppet && puppet.masterId === n2.id && !puppet.isDead) {
            if (!puppet.atWarWith.includes(n1.id)) {
                puppet.atWarWith.push(n1.id);
                if (!n1.atWarWith.includes(puppet.id)) n1.atWarWith.push(puppet.id);
                log(`${n2.name}ã®å‚€å„¡å›½ã€${puppet.name}ãŒå‚æˆ¦ã—ã¾ã—ãŸã€‚`, "log-war");
            }
        }
    });
}

function concludePeace(n1, n2, type) {
    // Determine winner/loser if applicable
    let winner = n1, loser = n2;
    if (n2.getMilitaryPower() > n1.getMilitaryPower()) {
        winner = n2;
        loser = n1;
    }

    n1.atWarWith = n1.atWarWith.filter(id => id !== n2.id);
    n2.atWarWith = n2.atWarWith.filter(id => id !== n1.id);

    if (type === 'WHITE_PEACE') {
        log(`ç™½ç´™è¬›å’Œ: ${n1.name}ã¨${n2.name}ãŒç¾çŠ¶ç¶­æŒã§åœæˆ¦ã—ã¾ã—ãŸã€‚`, "log-peace");
        n1.addHistory(`ç™½ç´™è¬›å’Œ: ${n2.name}ã¨åœæˆ¦`);
        n2.addHistory(`ç™½ç´™è¬›å’Œ: ${n1.name}ã¨åœæˆ¦`);
    } else if (type === 'PARTIAL_PEACE') {
        // Transfer some cities as a condition
        // å‹è€…ã®æœ¬å›½ã«è¿‘ã„éƒ½å¸‚ã‚’å„ªå…ˆçš„ã«å‰²è­²ã•ã›ã‚‹
        const numCitiesToTransfer = Math.min(loser.cities.length - 1, 2);
        
        if (numCitiesToTransfer > 0) {
            // è·é›¢è¨ˆç®—ç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼
            const getDist = (c1, c2) => {
                const dx = (c1.tileIdx % width) - c2.x;
                const dy = Math.floor(c1.tileIdx / width) - c2.y;
                return dx*dx + dy*dy;
            };

            // å‹è€…ã®é‡å¿ƒã«è¿‘ã„é †ã«ã‚½ãƒ¼ãƒˆ
            const sortedCities = [...loser.cities].sort((a, b) => {
                return getDist(a, winner.centroid) - getDist(b, winner.centroid);
            });

            const citiesToTake = sortedCities.slice(0, numCitiesToTransfer);

            citiesToTake.forEach(city => {
                // loser.citiesã‹ã‚‰å‰Šé™¤
                loser.cities = loser.cities.filter(c => c !== city);
                
                city.nationId = winner.id;
                winner.cities.push(city);
                
                // å‘¨è¾ºã‚¿ã‚¤ãƒ«ã®è­²æ¸¡
                const cx = city.tileIdx % width;
                const cy = Math.floor(city.tileIdx / width);
                const radius = 5;
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const nx = cx + dx;
                        const ny = cy + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const idx = ny * width + nx;
                            if (ownerGrid[idx] === loser.id) {
                                ownerGrid[idx] = winner.id;
                                winner.tiles.push(idx);
                                loser.tiles = loser.tiles.filter(t => t !== idx);
                            }
                        }
                    }
                }
            });
            log(`é€”ä¸­è¬›å’Œ: ${loser.name}ãŒé ˜åœŸã‚’å‰²è­²ã—ã€${winner.name}ã¨å’Œå¹³ã—ã¾ã—ãŸã€‚`, "log-peace");
            winner.addHistory(`è¬›å’Œ(å‹åˆ©): ${loser.name}ã‚ˆã‚Šé ˜åœŸç²å¾—`);
            loser.addHistory(`è¬›å’Œ(æ•—åŒ—): ${winner.name}ã¸é ˜åœŸå‰²è­²`);
        } else {
            log(`å’Œå¹³: ${n1.name}ã¨${n2.name}ãŒåœæˆ¦åˆæ„ã—ã¾ã—ãŸã€‚`, "log-peace");
        }
    } else if (type === 'ANNEX_BORDER') {
        // å›½å¢ƒåœ°å¸¯ã®å‰²è­² (ç´„20%)
        const targetCount = Math.floor(loser.tiles.length * 0.2);
        
        // 1. ç›´æ¥æ¥è§¦ã—ã¦ã„ã‚‹ã‚¿ã‚¤ãƒ«ã‚’ç‰¹å®š
        let borderTiles = [];
        for(const tIdx of loser.tiles) {
            const cx = tIdx % width;
            const cy = Math.floor(tIdx / width);
            let isBorder = false;
            const neighbors = [[0,1],[0,-1],[1,0],[-1,0]];
            for(const [dx, dy] of neighbors) {
                let nx=cx+dx, ny=cy+dy;
                if(nx>=0 && nx<width && ny>=0 && ny<height) {
                    let nIdx = ny*width+nx;
                    if(ownerGrid[nIdx] === winner.id) {
                        isBorder = true;
                        break;
                    }
                }
            }
            if(isBorder) borderTiles.push(tIdx);
        }

        if (borderTiles.length > 0) {
            const queue = [...borderTiles];
            const takenSet = new Set(borderTiles);
            
            let head = 0;
            while(head < queue.length && takenSet.size < targetCount) {
                const curr = queue[head++];
                const cx = curr % width;
                const cy = Math.floor(curr / width);

                const neighbors = [[0,1],[0,-1],[1,0],[-1,0]];
                for(const [dx, dy] of neighbors) {
                    let nx=cx+dx, ny=cy+dy;
                    if(nx>=0 && nx<width && ny>=0 && ny<height) {
                        let nIdx = ny*width+nx;
                        if(ownerGrid[nIdx] === loser.id && !takenSet.has(nIdx)) {
                            takenSet.add(nIdx);
                            queue.push(nIdx);
                        }
                    }
                }
            }

            // é ˜åœŸç§»è­²
            takenSet.forEach(tIdx => {
                ownerGrid[tIdx] = winner.id;
                winner.tiles.push(tIdx);
            });
            loser.tiles = loser.tiles.filter(t => !takenSet.has(t));

            // éƒ½å¸‚ç§»è­²
            for(let i=loser.cities.length-1; i>=0; i--) {
                const city = loser.cities[i];
                if(ownerGrid[city.tileIdx] === winner.id) {
                    city.nationId = winner.id;
                    winner.cities.push(city);
                    loser.cities.splice(i, 1);
                }
            }
            log(`å›½å¢ƒå‰²è­²: ${loser.name}ã¯å›½å¢ƒåœ°å¸¯ã‚’${winner.name}ã«å‰²è­²ã—ã¾ã—ãŸã€‚`, "log-peace");
            winner.addHistory(`è¬›å’Œ(å‹åˆ©): ${loser.name}ã‚ˆã‚Šå›½å¢ƒåœ°å¸¯ã‚’ç²å¾—`);
            loser.addHistory(`è¬›å’Œ(æ•—åŒ—): ${winner.name}ã¸å›½å¢ƒåœ°å¸¯ã‚’å‰²è­²`);
        } else {
             log(`å’Œå¹³: ${n1.name}ã¨${n2.name}ãŒåœæˆ¦åˆæ„ã—ã¾ã—ãŸã€‚`, "log-peace");
        }

    } else if (type === 'PUPPET') {
        // å‚€å„¡åŒ–æ™‚ã«é ˜åœŸã®2/3ã‚’å®—ä¸»å›½ãŒå¸åã™ã‚‹ãŒã€ç¶ºéº—ãªå›½å¢ƒã«ã™ã‚‹ãŸã‚ã«
        // æ•—æˆ¦å›½ã®é¦–éƒ½ã‚’ä¸­å¿ƒã«ç´„1/3ã®é ˜åœŸã‚’æ®‹ã—ã€æ®‹ã‚Šã‚’å‰²è­²ã•ã›ã‚‹ (BFS)
        const totalTiles = loser.tiles.length;
        const targetKeep = Math.ceil(totalTiles / 3);
        
        // é¦–éƒ½ã¾ãŸã¯æœ€åˆã®ã‚¿ã‚¤ãƒ«ã‚’èµ·ç‚¹ã«ã™ã‚‹
        let startTile = -1;
        if (loser.cities.length > 0) {
            startTile = loser.cities[0].tileIdx;
        } else if (loser.tiles.length > 0) {
            startTile = loser.tiles[0];
        }

        const keepSet = new Set();
        if (startTile !== -1) {
            const queue = [startTile];
            keepSet.add(startTile);

            let head = 0;
            while(head < queue.length && keepSet.size < targetKeep) {
                const curr = queue[head++];
                const cx = curr % width;
                const cy = Math.floor(curr / width);

                const neighbors = [
                    [cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]
                ];

                for(const [nx, ny] of neighbors) {
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        const nIdx = ny * width + nx;
                        // è‡ªåˆ†ã®é ˜åœŸã‹ã¤æœªè¨ªå•ãªã‚‰è¿½åŠ 
                        if (ownerGrid[nIdx] === loser.id && !keepSet.has(nIdx)) {
                            keepSet.add(nIdx);
                            queue.push(nIdx);
                            if (keepSet.size >= targetKeep) break;
                        }
                    }
                }
            }
        }

        // keepSetã«å«ã¾ã‚Œãªã„é ˜åœŸã‚’ã™ã¹ã¦å‹è€…ã«ç§»è­²
        const originalTiles = [...loser.tiles];
        loser.tiles = []; // ä¸€æ—¦ã‚¯ãƒªã‚¢ã—ã¦å†æ§‹ç¯‰

        originalTiles.forEach(tIdx => {
            if (keepSet.has(tIdx)) {
                loser.tiles.push(tIdx);
            } else {
                ownerGrid[tIdx] = winner.id;
                winner.tiles.push(tIdx);
            }
        });

        // éƒ½å¸‚ã®å§”è­²åˆ¤å®š
        for(let i=loser.cities.length-1; i>=0; i--) {
            const city = loser.cities[i];
            if(ownerGrid[city.tileIdx] === winner.id) {
                city.nationId = winner.id;
                winner.cities.push(city);
                loser.cities.splice(i, 1);
            }
        }

        loser.isPuppet = true;
        loser.masterId = winner.id;
        loser.puppetSince = year;
        loser.updateName();
        loser.stability = 50;
        winner.relations[loser.id] = 100;
        loser.relations[winner.id] = 100;
        
        // æ•—æˆ¦å›½ã®å‚€å„¡å›½ã‚’æˆ¦å‹å›½ã¸å§”è­²
        nations.forEach(vassal => {
            if (vassal.isPuppet && vassal.masterId === loser.id && !vassal.isDead) {
                vassal.masterId = winner.id;
                // åå‰æ›´æ–°ã¯ä¸è¦ã‹ã‚‚ã—ã‚Œãªã„ãŒã€å¿µã®ãŸã‚
                vassal.updateName();
                log(`æˆ¦å‹å›½ã«ã‚ˆã‚‹å‡¦åˆ†: ${vassal.name}ã®å®—ä¸»æ¨©ãŒ${winner.name}ã«ç§»è­²ã•ã‚Œã¾ã—ãŸã€‚`, "log-war");
            }
        });

        log(`æˆ¦å¾Œå‡¦ç†: ${loser.name}ã¯${winner.name}ã®å‚€å„¡å›½ã¨ãªã‚Šã¾ã—ãŸã€‚`, "log-war");
        winner.addHistory(`è¬›å’Œ(å®Œå…¨å‹åˆ©): ${loser.name}ã‚’å‚€å„¡åŒ–`);
        loser.addHistory(`è¬›å’Œ(å®Œå…¨æ•—åŒ—): ${winner.name}ã®å‚€å„¡ã¨ãªã‚‹`);
    } else {
        log(`å’Œå¹³: ${n1.name}ã¨${n2.name}ãŒåœæˆ¦åˆæ„ã—ã¾ã—ãŸã€‚`, "log-peace");
    }
}

function makePeace(n1, n2) {
    concludePeace(n1, n2, 'DEFAULT');
}

function battle(attacker, defender) {
    // æ”»æ’ƒå´ã®ãƒ‘ãƒ¯ãƒ¼ vs é˜²å¾¡å´ã®ãƒ‘ãƒ¯ãƒ¼ + åœ°å½¢ãƒœãƒ¼ãƒŠã‚¹
    const atkPow = attacker.getMilitaryPower() * (0.8 + Math.random()*0.4);
    const defPow = defender.getMilitaryPower() * (0.8 + Math.random()*0.4); // é˜²å¾¡æœ‰åˆ©ãªã—ã®æ¶ˆè€—æˆ¦

    // ã©ã¡ã‚‰ã‹ãŒé ˜åœŸã‚’å¥ªã†
    // æ”»æ’ƒå´ãŒåœ§å€’çš„ã«å¼·ã„å ´åˆ
    if (atkPow > defPow * 1.5) {
        // åœ§å€’çš„å‹åˆ©: 3ã‚¿ã‚¤ãƒ«å¥ªã†
        stealTerritory(attacker, defender);
        stealTerritory(attacker, defender);
        stealTerritory(attacker, defender);
        defender.soldiers = Math.max(0, Math.floor(defender.soldiers * 0.9));
    } else if (atkPow > defPow * 1.1) {
        stealTerritory(attacker, defender);
        // æ•—è€…ã¯å…µã‚’å¤±ã†
        defender.soldiers = Math.max(0, Math.floor(defender.soldiers * 0.95));
    } else {
        // æ”»æ’ƒå¤±æ•—ã€å…µã‚’å¤±ã†
        attacker.soldiers = Math.max(0, Math.floor(attacker.soldiers * 0.98));
    }
}

function navalLanding(attacker, defender) {
    if (!attacker.isCoastal() || !defender.isCoastal()) return;
    if (attacker.ships < 20) return; // ã‚ã‚‹ç¨‹åº¦ã®æµ·è»åŠ›ãŒå¿…è¦

    const atkNaval = attacker.getNavalPower() * (0.8 + Math.random()*0.4);
    const defNaval = defender.getNavalPower() * (0.8 + Math.random()*0.4);

    if (atkNaval > defNaval) {
        // ä¸Šé™¸æˆåŠŸ: æ•µã®æµ·å²¸ã‚¿ã‚¤ãƒ«ã‚’1ã¤å¥ªã†
        stealCoastalTerritory(attacker, defender);
        attacker.ships = Math.max(0, Math.floor(attacker.ships * 0.95)); // æ¶ˆè€—
    } else {
        // ä¸Šé™¸å¤±æ•—: æµ·è»åŠ›æ¶ˆè€—
        attacker.ships = Math.max(0, Math.floor(attacker.ships * 0.8));
    }
}

function stealCoastalTerritory(winner, loser) {
    // 1. æ²¿å²¸éƒ½å¸‚ã®å¥ªå–ã‚’å„ªå…ˆ
    const coastalCities = loser.cities.filter(city => {
        const cx = city.tileIdx % width;
        const cy = Math.floor(city.tileIdx / width);
        let isCoast = false;
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
            let nx=cx+dx, ny=cy+dy;
            if(nx>=0 && nx<width && ny>=0 && ny<height && grid[ny*width+nx] === 0) isCoast = true;
        });
        return isCoast;
    });

    if (coastalCities.length > 0 && Math.random() < 0.5) {
        const targetCity = coastalCities[Math.floor(Math.random() * coastalCities.length)];
        const cx = targetCity.tileIdx % width;
        const cy = Math.floor(targetCity.tileIdx / width);
        const radius = 4;
        
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const nx = cx + dx;
                const ny = cy + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    const idx = ny * width + nx;
                    if (ownerGrid[idx] === loser.id) {
                        ownerGrid[idx] = winner.id;
                        winner.tiles.push(idx);
                        loser.tiles = loser.tiles.filter(t => t !== idx);
                    }
                }
            }
        }
        targetCity.nationId = winner.id;
        winner.cities.push(targetCity);
        loser.cities = loser.cities.filter(c => c !== targetCity);
        loser.stability -= 15;
        log(`æµ·è»ä½œæˆ¦: ${winner.name}ãŒ${loser.name}ã®æ²¿å²¸éƒ½å¸‚ã€Œ${targetCity.name}ã€ã‚’å æ‹ ã—ã¾ã—ãŸï¼`, "log-war");
        return;
    }

    // 2. å¤±æ•—ã—ãŸå ´åˆã¯é€šå¸¸ã®æ²¿å²¸ã‚¿ã‚¤ãƒ«ã‚’å¥ªã†
    for(let i=0; i<100; i++) {
        let tile = loser.tiles[Math.floor(Math.random() * loser.tiles.length)];
        let cx = tile % width;
        let cy = Math.floor(tile / width);
        
        let isCoast = false;
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
            let nx=cx+dx, ny=cy+dy;
            if(nx>=0 && nx<width && ny>=0 && ny<height) {
                if(grid[ny*width+nx] === 0) isCoast = true;
            }
        });

        if (isCoast) {
            ownerGrid[tile] = winner.id;
            winner.tiles.push(tile);
            loser.tiles = loser.tiles.filter(t => t !== tile);
            loser.stability -= 5;
            log(`æµ·è»ä½œæˆ¦: ${winner.name}ãŒ${loser.name}ã¸ã®ä¸Šé™¸ä½œæˆ¦ã«æˆåŠŸã—ã¾ã—ãŸï¼`, "log-war");
            return;
        }
    }
}

function stealTerritory(winner, loser) {
    // æ•—è€…ã®é ˜åœŸã®ã†ã¡ã€å‹è€…ã¨æ¥ã—ã¦ã„ã‚‹ã‚¿ã‚¤ãƒ«ã‚’1ã¤å¥ªã†
    // è¨ˆç®—é‡å‰Šæ¸›ã®ãŸã‚ã€ãƒ©ãƒ³ãƒ€ãƒ ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã§å¢ƒç•Œã‚’æ¢ã™
    for(let i=0; i<20; i++) {
        let tile = winner.tiles[Math.floor(Math.random() * winner.tiles.length)];
        let cx = tile % width;
        let cy = Math.floor(tile / width);
        
        let targetIdx = -1;
        // éš£æ¥ã™ã‚‹æ•—è€…ã‚¿ã‚¤ãƒ«ã‚’æ¢ã™
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
            let nx=cx+dx, ny=cy+dy;
            if(nx>=0 && nx<width && ny>=0 && ny<height) {
                let idx = ny*width+nx;
                if(ownerGrid[idx] === loser.id) targetIdx = idx;
            }
        });

        if (targetIdx !== -1) {
            // åœ°å½¢ã«ã‚ˆã‚‹é€²è»é€Ÿåº¦ã®å¤‰å‹•
            const terrain = grid[targetIdx];
            let difficulty = 1;
            if (terrain === 2) difficulty = 4; // å±±å²³: 1/4ã®ç¢ºç‡
            if (terrain === 3) difficulty = 2; // æ²³å·: 1/2ã®ç¢ºç‡
            
            if (Math.random() > (1 / difficulty)) return; // å¤±æ•—ï¼ˆé€²è»åœæ­¢ï¼‰

            // é ˜åœŸç§»å‹•å‡¦ç†
            ownerGrid[targetIdx] = winner.id;
            winner.tiles.push(targetIdx);
            loser.tiles = loser.tiles.filter(t => t !== targetIdx);

            loser.stability -= 5;

            // Aggressive Expansion: ä»–å›½ã¨ã®é–¢ä¿‚æ‚ªåŒ–
            nations.forEach(other => {
                if (other.id !== winner.id && !other.isDead) {
                    if (winner.relations[other.id] !== undefined) {
                        winner.relations[other.id] -= 1; // å°ã•ãªè“„ç©
                    }
                }
            });
            worldTension = Math.min(100, worldTension + 0.1);

            return; // 1ã‚¿ãƒ¼ãƒ³1ã‚¿ã‚¤ãƒ«ã®ã¿
        }
    }
}

/**
 * UI & Utility
 */
function updateNationPanel() {
    if (selectedNationId === -1) return;
    const n = nations.find(nat => nat.id === selectedNationId);
    if (!n) return;

    document.getElementById('n-name').innerText = n.name + (n.isDead ? " (æ»…äº¡)" : "");
    document.getElementById('n-name').style.color = n.color;
    document.getElementById('n-leader').innerText = n.leader;
    
    document.getElementById('n-eco').innerText = n.ecoIdeology || '-';
    document.getElementById('n-sys-broad').innerText = n.sysBroad || '-';
    document.getElementById('n-gov').innerText = n.sysDetailed || n.govType;
    document.getElementById('n-struct').innerText = n.stateStruct || '-';
    document.getElementById('n-sov').innerText = n.sovereign || '-';

    document.getElementById('n-religion').innerText = n.religion;
    document.getElementById('n-tech').innerText = TECH_LEVELS[n.tech];
    document.getElementById('n-stability').innerText = Math.floor(n.stability) + "%";
    document.getElementById('n-governance').innerText = Math.floor(n.governance);
    
    document.getElementById('n-gdp').innerText = formatNum(n.gdp);
    document.getElementById('bar-gdp').style.width = Math.min(100, n.gdp / 1000) + "%";
    
    document.getElementById('n-pop').innerText = formatNum(n.pop);
    document.getElementById('bar-pop').style.width = Math.min(100, n.pop / 50000) + "%";
    
    document.getElementById('n-mil').innerText = formatNum(n.soldiers);
    document.getElementById('bar-mil').style.width = Math.min(100, n.soldiers / 5000) + "%";
    
    document.getElementById('n-ind').innerText = n.industry;
    document.getElementById('n-tanks').innerText = n.tanks;
    document.getElementById('n-ships').innerText = n.ships;
    document.getElementById('n-qual').innerText = n.soldierQuality.toFixed(2);
}

function log(msg, className) {
    const logEl = document.getElementById('log');
    const line = document.createElement('div');
    line.innerText = `[Y${year}] ${msg}`;
    if (className) line.className = className;
    logEl.prepend(line);
    if (logEl.children.length > 50) logEl.lastChild.remove();
}

function formatNum(num) {
    if (num >= 100000000) return (num/100000000).toFixed(1) + "å„„";
    if (num >= 10000) return (num/10000).toFixed(1) + "ä¸‡";
    return Math.floor(num);
}

function clamp(val, min, max) {
    return Math.min(Math.max(val, min), max);
}

function drawStar(cx, cy, spikes, outerRadius, innerRadius, color) {
    let rot = Math.PI / 2 * 3;
    let x = cx;
    let y = cy;
    let step = Math.PI / spikes;

    ctx.beginPath();
    ctx.moveTo(cx, cy - outerRadius)
    for (let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius;
        y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y)
        rot += step

        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y)
        rot += step
    }
    ctx.lineTo(cx, cy - outerRadius)
    ctx.closePath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'black';
    ctx.stroke();
    ctx.fillStyle = color;
    ctx.fill();
}

</script>
</body>
</html>
