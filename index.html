<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ファンタジー世界シミュレーター</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0c0c0c; color: #e0e0e0; font-family: 'Segoe UI', 'Roboto', sans-serif; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; cursor: crosshair; background: #000; }
        canvas { display: block; image-rendering: pixelated; }
        #sidebar { width: 320px; background: #1a1a1a; padding: 20px; overflow-y: auto; box-shadow: -2px 0 10px rgba(0,0,0,0.8); display: flex; flex-direction: column; gap: 15px; border-left: 1px solid #333; }

        @media (max-width: 768px) {
            #container { flex-direction: column; }
            #sidebar { width: 100%; height: 40vh; border-left: none; border-top: 1px solid #333; box-sizing: border-box; }
            #canvas-container { height: 60vh; }
        }
        
        h1, h2 { margin: 0 0 10px 0; color: #ccc; text-transform: uppercase; letter-spacing: 2px; font-weight: 300; }
        h1 { font-size: 1.4em; border-bottom: 1px solid #555; padding-bottom: 8px; color: #4db8ff; }
        .panel { background: #222; padding: 15px; border-radius: 0; border: 1px solid #444; margin-bottom: 10px; }
        button { background: #34495e; border: 1px solid #5d6d7e; padding: 10px; color: #ecf0f1; font-weight: bold; cursor: pointer; width: 100%; margin-top: 5px; transition: 0.2s; }
        button:hover { background: #4db8ff; color: #000; }
        button:disabled { background: #666; cursor: not-allowed; }
        
        .stat-row { display: flex; justify-content: space-between; font-size: 0.9em; margin-bottom: 3px; }
        .bar-bg { background: #222; height: 6px; border-radius: 3px; overflow: hidden; margin-bottom: 8px; }
        .bar-fill { height: 100%; background: #ccc; }
        
        #log { font-size: 0.8em; height: 150px; overflow-y: auto; background: #111; padding: 5px; font-family: monospace; border: 1px solid #555; }
        .log-war { color: #ff6b6b; }
        .log-peace { color: #51cf66; }
        .log-info { color: #aaa; }
        
        /* Tooltip style overlay */
        #hover-info { position: absolute; background: rgba(0,0,0,0.8); padding: 5px; pointer-events: none; border-radius: 4px; display: none; font-size: 0.8em; z-index: 10; border: 1px solid #666; }
    </style>
</head>
<body>

<div id="container">
    <div id="canvas-container">
        <canvas id="gameCanvas"></canvas>
        <div id="hover-info"></div>
    </div>
    
    <div id="sidebar">
        <h1>世界シミュレーター</h1>
        
        <div id="menu-panel" class="panel">
            <h2>1. マップデザイン</h2>
            <p>左クリック/タッチ: 描画 (右クリックで消去)</p>
            <button id="btn-brush" style="margin-bottom:10px;">ブラシ: 陸地</button>
            <div>
                サイズ: <select id="mapSize">
                    <option value="64">小 (64x64)</option>
                    <option value="128" selected>中 (128x128)</option>
                    <option value="256">大 (256x256)</option>
                </select>
            </div>
            <button id="btn-fill" style="margin-bottom:10px;">塗りつぶしモード: オフ</button>
            <button id="btn-generate">世界を生成 (シミュレーション開始)</button>
        </div>

        <div id="sim-panel" class="panel" style="display:none;">
            <h2>2. 世界情勢</h2>
            <div class="stat-row"><span>年:</span> <span id="info-year">1</span></div>
            <div class="stat-row"><span>総人口:</span> <span id="info-pop">0</span></div>
            <div class="stat-row"><span>緊張度:</span> <span id="info-tension">0%</span></div>
            <div class="stat-row"><span>速度:</span> <input type="range" id="simSpeed" min="1" max="10" value="5" style="width:100px;"></div>
            <button id="btn-map-mode" style="margin-bottom:10px;">地図モード: 政治</button>
            <button id="btn-pause">一時停止 / 再開</button>
        </div>

        <div id="nation-panel" class="panel" style="display:none;">
            <h2 id="n-name">国家名</h2>
            <div class="stat-row"><span>指導者:</span> <span id="n-leader"></span></div>
            <div class="stat-row"><span>体制:</span> <span id="n-gov"></span></div>
            <div class="stat-row"><span>宗教:</span> <span id="n-religion"></span></div>
            <div class="stat-row"><span>技術:</span> <span id="n-tech"></span></div>
            <div class="stat-row"><span>安定度:</span> <span id="n-stability"></span></div>
            
            <hr style="border-color:#555">
            
            <div class="stat-row"><span>国内総生産(GDP):</span> <span id="n-gdp"></span></div>
            <div class="bar-bg"><div id="bar-gdp" class="bar-fill" style="width:0; background:#f1c40f"></div></div>
            
            <div class="stat-row"><span>人口:</span> <span id="n-pop"></span></div>
            <div class="bar-bg"><div id="bar-pop" class="bar-fill" style="width:0; background:#2ecc71"></div></div>
            
            <div class="stat-row"><span>軍事力:</span> <span id="n-mil"></span></div>
            <div class="bar-bg"><div id="bar-mil" class="bar-fill" style="width:0; background:#e74c3c"></div></div>

            <div class="stat-row"><span>工業力:</span> <span id="n-ind"></span></div>
            <div class="stat-row"><span>戦車数:</span> <span id="n-tanks"></span></div>
            <div class="stat-row"><span>海軍力:</span> <span id="n-ships"></span></div>
            <div class="stat-row"><span>軍の質:</span> <span id="n-qual"></span></div>
        </div>

        <div class="panel">
            <h2>イベントログ</h2>
            <div id="log"></div>
        </div>
    </div>
</div>

<script>
/**
 * 定数と設定
 */
const TILE_SIZE = 6; // 描画時の1タイルのピクセルサイズ
const COLORS = {
    WATER: '#1a2a3a',
    LAND: '#3c4d3c',
    MOUNTAIN: '#4a4a4a',
    RIVER: '#2980b9',
    SNOW: '#ecf0f1'
};
const RELIGIONS = ['太陽神教', '海霊信仰', '機械崇拝', '自然の秩序', '混沌', '虚無'];
const TECH_LEVELS = ['原始的', '農耕社会', '工業化', '現代的', '未来的'];

// グローバル変数
let canvas, ctx, width, height;
let grid = []; // 0:Water, 1:Land, 2:Mountain, 3:River
let ownerGrid = []; // ID of the nation owning this tile (-1 for none)
let nations = [];
let nationIdCounter = 0;
let isDrawing = true;
let isFillMode = false;
let currentBrush = 1; // 1:Land, 0:Water
let mapMode = 'political'; // political or terrain
let mapScale = 1.0;
let isPaused = true;
let simSpeed = 5;
let frameCounter = 0;
let worldTension = 0;
let year = 1;
let animationFrame;
let selectedNationId = -1;

// マウス操作用
let mousePressed = false;
let mouseButton = 0; // 0:Left, 2:Right

/**
 * 初期化
 */
window.onload = () => {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    
    // キャンバスサイズ調整
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // グリッド初期化 (中サイズデフォルト)
    initGrid(128);

    // イベントリスナー
    setupInput();
    
    // ループ開始
    loop();
};

function resizeCanvas() {
    const container = document.getElementById('canvas-container');
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
}

function initGrid(size) {
    width = size;
    height = size;
    grid = new Array(width * height).fill(0);
    ownerGrid = new Array(width * height).fill(-1);
    nations = [];
    isDrawing = true;
    year = 1;
    document.getElementById('log').innerHTML = '';
}

/**
 * 入力処理
 */
function setupInput() {
    // 描画ツール
    canvas.addEventListener('mousedown', e => {
        mousePressed = true;
        mouseButton = e.button;
        handleDraw(e);
        handleSelect(e);
    });
    canvas.addEventListener('mousemove', e => {
        handleDraw(e);
        handleHover(e);
    });
    window.addEventListener('mouseup', () => mousePressed = false);

    // タッチ操作対応
    canvas.addEventListener('touchstart', e => {
        mousePressed = true;
        mouseButton = 0; // タッチは左クリック扱い
        handleDraw(e);
        handleSelect(e);
        e.preventDefault();
    }, { passive: false });
    canvas.addEventListener('touchmove', e => {
        handleDraw(e);
        handleHover(e);
        e.preventDefault();
    }, { passive: false });
    canvas.addEventListener('touchend', () => {
        mousePressed = false;
    });
    
    // 右クリックメニュー無効化
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // UIボタン
    document.getElementById('mapSize').addEventListener('change', (e) => {
        initGrid(parseInt(e.target.value));
    });

    document.getElementById('btn-generate').addEventListener('click', () => {
        generateWorld();
    });

    document.getElementById('btn-pause').addEventListener('click', () => {
        isPaused = !isPaused;
    });

    document.getElementById('btn-map-mode').addEventListener('click', (e) => {
        mapMode = (mapMode === 'political' ? 'terrain' : 'political');
        e.target.innerText = `地図モード: ${mapMode === 'political' ? '政治' : '地形'}`;
    });

    document.getElementById('simSpeed').addEventListener('input', (e) => {
        simSpeed = parseInt(e.target.value);
    });

    document.getElementById('btn-fill').addEventListener('click', (e) => {
        isFillMode = !isFillMode;
        e.target.innerText = `塗りつぶしモード: ${isFillMode ? 'オン' : 'オフ'}`;
        e.target.style.background = isFillMode ? '#4db8ff' : '#34495e';
        e.target.style.color = isFillMode ? '#000' : '#ecf0f1';
    });

    document.getElementById('btn-brush').addEventListener('click', (e) => {
        currentBrush = currentBrush === 1 ? 0 : 1;
        e.target.innerText = `ブラシ: ${currentBrush === 1 ? '陸地' : '海'}`;
        e.target.style.background = currentBrush === 1 ? '#34495e' : '#2980b9';
    });
}

/**
 * 描画モードの処理
 */
function handleDraw(e) {
    if (!mousePressed || !isDrawing) return;
    
    const {x, y} = getGridPos(e);

    if (x >= 0 && x < width && y >= 0 && y < height) {
        const targetType = (e.type.startsWith('touch') || mouseButton === 0) ? currentBrush : (currentBrush === 1 ? 0 : 1);
        
        if (isFillMode) {
            // 塗りつぶし（クリックした瞬間のみ実行したいが、mousedownでも呼ばれるのでOK）
            // mousemove中に塗りつぶしを連打すると重いので、mousedownの時だけにする工夫が必要
            if (e.type === 'mousedown' || e.type === 'touchstart') {
                floodFill(x, y, targetType);
            }
        } else {
            // ブラシサイズ（少し太く）
            for(let dy=-1; dy<=1; dy++){
                for(let dx=-1; dx<=1; dx++){
                    const nx = x+dx;
                    const ny = y+dy;
                    if(nx>=0 && nx<width && ny>=0 && ny<height){
                        const idx = ny * width + nx;
                        grid[idx] = targetType;
                    }
                }
            }
        }
    }
}

function floodFill(startX, startY, newType) {
    const oldType = grid[startY * width + startX];
    if (oldType === newType) return;

    const stack = [[startX, startY]];
    while (stack.length > 0) {
        const [x, y] = stack.pop();
        const idx = y * width + x;

        if (grid[idx] === oldType) {
            grid[idx] = newType;

            if (x > 0) stack.push([x - 1, y]);
            if (x < width - 1) stack.push([x + 1, y]);
            if (y > 0) stack.push([x, y - 1]);
            if (y < height - 1) stack.push([x, y + 1]);
        }
    }
}

/**
 * 選択とホバー
 */
function handleSelect(e) {
    if (isDrawing) return;
    const {x, y} = getGridPos(e);
    if (x >= 0 && x < width && y >= 0 && y < height) {
        const idx = y * width + x;
        const owner = ownerGrid[idx];
        if (owner !== -1) {
            selectedNationId = owner;
            updateNationPanel();
            document.getElementById('nation-panel').style.display = 'block';
        } else {
            document.getElementById('nation-panel').style.display = 'none';
            selectedNationId = -1;
        }
    }
}

function handleHover(e) {
    const hoverInfo = document.getElementById('hover-info');
    if (isDrawing) {
        hoverInfo.style.display = 'none';
        return;
    }
    
    const {x, y} = getGridPos(e);
    if (x >= 0 && x < width && y >= 0 && y < height) {
        const idx = y * width + x;
        const owner = ownerGrid[idx];
        if (owner !== -1) {
            const n = nations.find(nat => nat.id === owner);
            if(n) {
                const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
                const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
                hoverInfo.style.display = 'block';
                hoverInfo.style.left = (clientX + 10) + 'px';
                hoverInfo.style.top = (clientY + 10) + 'px';
                hoverInfo.innerHTML = `<b>${n.name}</b><br>人口: ${formatNum(n.pop)}`;
                return;
            }
        }
    }
    hoverInfo.style.display = 'none';
}

function getGridPos(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
    const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
    
    const relX = clientX - rect.left - canvas.width/2;
    const relY = clientY - rect.top - canvas.height/2;
    const x = Math.floor((relX / mapScale + (width*TILE_SIZE)/2) / TILE_SIZE);
    const y = Math.floor((relY / mapScale + (height*TILE_SIZE)/2) / TILE_SIZE);
    return {x, y};
}

/**
 * ワールド生成ロジック
 */
function generateWorld() {
    isDrawing = false;
    document.getElementById('menu-panel').style.display = 'none';
    document.getElementById('sim-panel').style.display = 'block';

    // 1. 地形補正 (山と川)
    generateTerrainFeatures();

    // 2. 国家生成
    spawnNations();

    log("世界が生成されました。歴史が始まります。", "log-info");
}

function generateTerrainFeatures() {
    // 1. 海岸線からの距離マップを作成 (2パス・ディスタンス・トランスフォーム)
    let distMap = new Array(width * height).fill(width * height);
    
    // パス1: 左上から右下へ
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            let idx = y * width + x;
            if (grid[idx] === 0) {
                distMap[idx] = 0;
            } else {
                let left = (x > 0) ? distMap[idx - 1] : width * height;
                let top = (y > 0) ? distMap[idx - width] : width * height;
                distMap[idx] = Math.min(distMap[idx], Math.min(left, top) + 1);
            }
        }
    }
    // パス2: 右下から左上へ
    for (let y = height - 1; y >= 0; y--) {
        for (let x = width - 1; x >= 0; x--) {
            let idx = y * width + x;
            if (grid[idx] !== 0) {
                let right = (x < width - 1) ? distMap[idx + 1] : width * height;
                let bottom = (y < height - 1) ? distMap[idx + width] : width * height;
                distMap[idx] = Math.min(distMap[idx], Math.min(right, bottom) + 1);
            }
        }
    }

    // 2. 山脈の生成 (島の中央部、つまり距離が極大になる付近に沿って生成)
    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            let idx = y * width + x;
            if (grid[idx] === 1 && distMap[idx] >= 4) {
                let isLocalMax = true;
                let val = distMap[idx];
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        if (distMap[(y + dy) * width + (x + dx)] > val) {
                            isLocalMax = false;
                            break;
                        }
                    }
                    if (!isLocalMax) break;
                }
                
                if (isLocalMax && Math.random() < 0.8) {
                    grid[idx] = 2; // 山
                    // 山脈を広げる (山脈の方向に慣性を持たせる)
                    let cx = x, cy = y;
                    let lastDx = 0, lastDy = 0;
                    let rangeLen = 5 + Math.random() * 20;
                    for (let len = 0; len < rangeLen; len++) {
                        let candidates = [];
                        [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]].forEach(([dx, dy]) => {
                            let nx = cx + dx, ny = cy + dy;
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                let nIdx = ny * width + nx;
                                if (grid[nIdx] === 1 && distMap[nIdx] >= 3) {
                                    // 前回の方向と同じ方向を優先
                                    let weight = (dx === lastDx && dy === lastDy) ? 5 : 1;
                                    for(let w=0; w<weight; w++) candidates.push({x: nx, y: ny, dx, dy});
                                }
                            }
                        });
                        if (candidates.length === 0) break;
                        let next = candidates[Math.floor(Math.random() * candidates.length)];
                        cx = next.x; cy = next.y;
                        lastDx = next.dx; lastDy = next.dy;
                        grid[cy * width + cx] = 2;
                    }
                }
            }
        }
    }

    // 3. 川の生成 (山から海へ、勾配を下る)
    let riverOrigins = [];
    for (let i = 0; i < width * height; i++) {
        if (grid[i] === 2 && Math.random() < 0.3) riverOrigins.push(i);
    }
    
    riverOrigins.forEach(origin => {
        let cx = origin % width;
        let cy = Math.floor(origin / width);
        let path = [origin];
        let life = 200;
        while (life > 0) {
            let candidates = [];
            let currentH = distMap[cy * width + cx];
            
            [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                let nx = cx + dx, ny = cy + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    let idx = ny * width + nx;
                    if (path.includes(idx)) return;
                    let h = distMap[idx];
                    if (h <= currentH) {
                        candidates.push({x: nx, y: ny, h: h, idx: idx});
                    }
                }
            });

            if (candidates.length === 0) break;
            // 勾配が最も急な方向を優先しつつ、少しランダム性を入れる
            candidates.sort((a, b) => a.h - b.h);
            let next = candidates[0];
            if (Math.random() < 0.4 && candidates.length > 1) next = candidates[Math.floor(Math.random() * Math.min(candidates.length, 3))];
            
            cx = next.x; cy = next.y;
            path.push(next.idx);
            if (grid[next.idx] === 0) break; // 海に到達
            if (grid[next.idx] === 1) grid[next.idx] = 3; // 平地なら川にする
            life--;
        }
    });
}

/**
 * 都市クラス
 */
class City {
    constructor(name, tileIdx, nationId) {
        this.name = name;
        this.tileIdx = tileIdx;
        this.nationId = nationId;
        this.unrest = 0;
    }
}

/**
 * 国家クラス
 */
class Nation {
    constructor(id, x, y) {
        this.id = (id !== undefined) ? id : nationIdCounter++;
        this.color = `hsl(${Math.random()*360}, 70%, 50%)`;
        this.baseName = this.generateBaseName();
        this.regimeNumber = 1;
        this.religion = RELIGIONS[Math.floor(Math.random() * RELIGIONS.length)];
        
        // Stats
        this.pop = 1000 + Math.floor(Math.random() * 5000);
        this.gdp = 100 + Math.floor(Math.random() * 900); // 1人あたりではない、国力ベース
        this.industry = 10 + Math.floor(Math.random() * 50);
        this.tech = 0; // Index of TECH_LEVELS
        
        // Politics
        const startGovs = ["絶対王政", "共和制", "帝国", "公国", "連邦制"];
        this.govType = startGovs[Math.floor(Math.random() * startGovs.length)];
        this.updateName();
        this.stability = 100;
        this.unrest = 0;
        this.leader = this.generateLeaderName();
        
        // Military
        this.soldiers = Math.floor(this.pop * 0.1);
        this.soldierQuality = 0.5 + Math.random(); // 0.5 - 1.5
        this.equipQuality = 0.5 + Math.random();
        this.tanks = 0;
        this.ships = 0;
        
        // Diplomacy
        this.relations = {}; // { nationId: value (-100 to 100) }
        this.atWarWith = []; // list of nation IDs
        this.centroid = {x: 0, y: 0};
        this.isDead = false;
        this.isRebel = false;
        this.parentName = "";
        this.rebellionCooldown = 0;
        this.isPuppet = false;
        this.masterId = -1;
        this.puppetSince = 0;
        
        this.cities = [];

        // 初期領土
        if (x !== undefined && y !== undefined) {
            const tileIdx = y * width + x;
            ownerGrid[tileIdx] = this.id;
            this.tiles = [tileIdx];
            // 初期都市（首都）の生成
            this.cities.push(new City(this.baseName + "府", tileIdx, this.id));
        } else {
            this.tiles = [];
        }
    }

    generateBaseName() {
        const syl = ["アル", "バン", "シー", "ドル", "エル", "ファ", "ゴル", "ハン", "イル", "ジョ", "カ", "ロル", "ミ", "ノル", "パ", "ク", "ロ", "サ", "ティ", "ウル", "ヴァ", "キ", "ズ"];
        return syl[Math.floor(Math.random()*syl.length)] + syl[Math.floor(Math.random()*syl.length)];
    }

    generateCityName() {
        const syl = ["アル", "バン", "シー", "ドル", "エル", "ファ", "ゴル", "ハン", "イル", "ジョ", "カ", "ロル", "ミ", "ノル", "パ", "ク", "ロ", "サ", "ティ", "ウル", "ヴァ", "キ", "ズ"];
        const suffix = ["市", "府", "京", "要塞", "港", "都"];
        return syl[Math.floor(Math.random()*syl.length)] + syl[Math.floor(Math.random()*syl.length)] + suffix[Math.floor(Math.random()*suffix.length)];
    }

    updateName() {
        if (this.isPuppet) {
            this.name = this.baseName + "傀儡統治機構国";
            return;
        }

        const suffixes = {
            "絶対王政": "王国",
            "共和制": "共和国",
            "帝国": "帝国",
            "公国": "公国",
            "連邦制": "連邦",
            "独裁制": "国",
            "軍事政権": "国",
            "革命政府": "革命政府",
            "臨時政府": "臨時政府",
            "正統政府": "正統政府"
        };
        let suffix = suffixes[this.govType] || "国";
        
        if (this.govType === "共和制" && this.regimeNumber > 1) {
            this.name = this.baseName + suffix + "第" + this.regimeNumber + "政";
        } else {
            this.name = this.baseName + suffix;
        }
    }

    generateLeaderName() {
        const first = ["ヨハン", "フリードリヒ", "ルイ", "チャールズ", "アレクサンダー", "ニコライ", "マリア", "エリザベス", "ヴィクトリア", "カトリーヌ", "スレイマン", "カンヒ", "メイジ", "グスタフ", "カメハメハ"];
        const last = ["世", "大王", "公", "卿", "・ボナパルト", "・ロマノフ", "・ハプスブルク", "・ブルボン", "・テューダー", "・ホーエンツォレルン"];
        if (Math.random() < 0.7) {
            return first[Math.floor(Math.random() * first.length)] + (Math.random() < 0.5 ? last[Math.floor(Math.random() * last.length)] : "");
        } else {
            // 日本風
            const jpFirst = ["織田", "豊臣", "徳川", "武田", "上杉", "毛利", "島津", "伊達"];
            const jpLast = ["信長", "秀吉", "家康", "信玄", "謙信", "元就", "義久", "政宗"];
            return jpFirst[Math.floor(Math.random() * jpFirst.length)] + jpLast[Math.floor(Math.random() * jpLast.length)];
        }
    }

    getMilitaryPower() {
        // 軍事力計算式: 兵数 * 質 * 装備 * (戦車ボーナス)
        let tankBonus = 1 + (this.tanks * 0.05);
        return this.soldiers * this.soldierQuality * this.equipQuality * tankBonus * (1 + this.tech * 0.5);
    }

    getNavalPower() {
        return this.ships * (1 + this.tech * 0.5) * this.equipQuality;
    }

    updateCentroid() {
        if (this.tiles.length > 0) {
            let sumX = 0, sumY = 0;
            for (let i = 0; i < this.tiles.length; i++) {
                const tileIdx = this.tiles[i];
                sumX += tileIdx % width;
                sumY += Math.floor(tileIdx / width);
            }
            this.centroid.x = sumX / this.tiles.length;
            this.centroid.y = sumY / this.tiles.length;
        }
    }

    isCoastal() {
        // 少なくとも1つのタイルが海(0)に接しているか (サンプリング)
        const samples = Math.min(this.tiles.length, 30);
        for(let i=0; i<samples; i++) {
            let tile = this.tiles[Math.floor(Math.random() * this.tiles.length)];
            let cx = tile % width;
            let cy = Math.floor(tile / width);
            let found = false;
            [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
                let nx=cx+dx, ny=cy+dy;
                if(nx>=0 && nx<width && ny>=0 && ny<height) {
                    if(grid[ny*width+nx] === 0) found = true;
                }
            });
            if(found) return true;
        }
        return false;
    }
}

function spawnNations() {
    let landTiles = [];
    for(let i=0; i<grid.length; i++) {
        if(grid[i] === 1) landTiles.push(i);
    }

    // 土地の広さに応じて国家数を決定
    const numNations = Math.max(2, Math.floor(landTiles.length / 50)); 
    nationIdCounter = 0;
    
    for(let i=0; i<numNations; i++) {
        if(landTiles.length === 0) break;
        // ランダムな陸地を選ぶ
        let rndIdx = Math.floor(Math.random() * landTiles.length);
        let tileIdx = landTiles[rndIdx];
        landTiles.splice(rndIdx, 1);
        
        let y = Math.floor(tileIdx / width);
        let x = tileIdx % width;
        
        // 既に誰かの領土ならスキップ（初期配置は離す）
        if(ownerGrid[tileIdx] !== -1) continue;
        
        nations.push(new Nation(undefined, x, y));
    }
    
    // 初期領土拡大 (Flood fill的)
    expandTerritoryInitial();
}

function expandTerritoryInitial() {
    // 簡易的に各国の周囲を埋める
    let changed = true;
    let loopCount = 0;
    while(changed && loopCount < 20) {
        changed = false;
        let newOwners = [...ownerGrid];
        
        // ランダムな順序で処理するためにシャッフル
        let indices = Array.from({length: width*height}, (_, i) => i);
        indices.sort(() => Math.random() - 0.5);

        for(let i of indices) {
            if(grid[i] === 0) continue; // 海は無視
            if(ownerGrid[i] !== -1) continue; // 所有者あり

            // 隣接タイルをチェック
            let neighbors = [];
            let cx = i % width;
            let cy = Math.floor(i / width);
            
            [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
                let nx=cx+dx, ny=cy+dy;
                if(nx>=0 && nx<width && ny>=0 && ny<height) {
                    let nIdx = ny*width+nx;
                    if(ownerGrid[nIdx] !== -1) neighbors.push(ownerGrid[nIdx]);
                }
            });

            if(neighbors.length > 0) {
                // 最も多い隣国に吸収される確率が高い
                let chosen = neighbors[Math.floor(Math.random()*neighbors.length)];
                newOwners[i] = chosen;
                nations[chosen].tiles.push(i);
                changed = true;
            }
        }
        ownerGrid = newOwners;
        loopCount++;
    }

    // 初期重心計算
    nations.forEach(n => n.updateCentroid());
}


/**
 * メインループとシミュレーション
 */
function loop() {
    ctx.fillStyle = "#222";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    renderMap();
    
    if (!isDrawing && !isPaused) {
        frameCounter++;
        if (frameCounter >= (11 - simSpeed)) {
            frameCounter = 0;
            simulateTick();
            year++;
            document.getElementById('info-year').innerText = year;
            document.getElementById('info-tension').innerText = worldTension.toFixed(1) + "%";
            document.getElementById('info-tension').style.color = `rgb(${worldTension*2.55}, ${255 - worldTension*2.55}, 0)`;
        }
    }

    if (selectedNationId !== -1) updateNationPanel();

    animationFrame = requestAnimationFrame(loop);
}

function renderMap() {
    mapScale = Math.min(canvas.width / (width * TILE_SIZE), canvas.height / (height * TILE_SIZE));
    if (mapScale > 1.0) mapScale = 1.0;

    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.scale(mapScale, mapScale);
    ctx.translate(-(width * TILE_SIZE) / 2, -(height * TILE_SIZE) / 2);

    const offsetX = 0;
    const offsetY = 0;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = y * width + x;
            const type = grid[i];
            const owner = ownerGrid[i];
            
            let color = COLORS.WATER;
            if (type === 1) color = COLORS.LAND;
            if (type === 2) color = COLORS.MOUNTAIN;
            if (type === 3) color = COLORS.RIVER;

            // 国の色オーバーレイ
            if (owner !== -1 && !isDrawing) {
                const nat = nations.find(n => n.id === owner);
                if (nat) {
                    if (mapMode === 'political') {
                        // 傀儡国は宗主国の色を使用
                        let fillColor = nat.color;
                        if (nat.isPuppet && nat.masterId !== -1) {
                            const master = nations.find(m => m.id === nat.masterId);
                            if (master) fillColor = master.color;
                        }

                        // 国の色をベースにするが、地形も見せる (透過させる)
                        ctx.globalAlpha = 0.6;
                        ctx.fillStyle = fillColor;
                        ctx.fillRect(offsetX + x*TILE_SIZE, offsetY + y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        ctx.globalAlpha = 1.0;
                    } else {
                        // 地形をベースにする
                        ctx.fillStyle = color;
                        ctx.fillRect(offsetX + x*TILE_SIZE, offsetY + y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                    
                    // 山や川の場合は装飾 (常に表示)
                    if (type === 2) { // 山
                        ctx.fillStyle = "rgba(0,0,0,0.5)";
                        ctx.fillRect(offsetX + x*TILE_SIZE+1, offsetY + y*TILE_SIZE+1, TILE_SIZE-2, TILE_SIZE-2);
                    }
                    else if (type === 3) { // 川
                        ctx.fillStyle = "rgba(100,200,255,0.6)";
                        ctx.fillRect(offsetX + x*TILE_SIZE + TILE_SIZE/3, offsetY + y*TILE_SIZE, TILE_SIZE/3, TILE_SIZE);
                    }
                }
            } else {
                // 描画モード or 領土なし
                ctx.fillStyle = color;
                ctx.fillRect(offsetX + x*TILE_SIZE, offsetY + y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }
    }
    
    // 国境線の描画 (HOI4スタイル)
    if (!isDrawing) {
        ctx.lineWidth = 2;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = y * width + x;
                const owner = ownerGrid[i];
                if (owner === -1) continue;

                const rightOwner = (x < width - 1) ? ownerGrid[i + 1] : -2;
                const bottomOwner = (y < height - 1) ? ownerGrid[i + width] : -2;

                if (owner !== rightOwner) {
                    ctx.strokeStyle = "rgba(0,0,0,0.5)";
                    ctx.beginPath();
                    ctx.moveTo(offsetX + (x + 1) * TILE_SIZE, offsetY + y * TILE_SIZE);
                    ctx.lineTo(offsetX + (x + 1) * TILE_SIZE, offsetY + (y + 1) * TILE_SIZE);
                    ctx.stroke();
                }
                if (owner !== bottomOwner) {
                    ctx.strokeStyle = "rgba(0,0,0,0.5)";
                    ctx.beginPath();
                    ctx.moveTo(offsetX + x * TILE_SIZE, offsetY + (y + 1) * TILE_SIZE);
                    ctx.lineTo(offsetX + (x + 1) * TILE_SIZE, offsetY + (y + 1) * TILE_SIZE);
                    ctx.stroke();
                }
            }
        }
    }

    // 都市の描画
    if (!isDrawing) {
        nations.forEach(n => {
            if (n.isDead) return;
            n.cities.forEach((city, idx) => {
                const cx = city.tileIdx % width;
                const cy = Math.floor(city.tileIdx / width);
                
                if (idx === 0) {
                    // 首都: 星形
                    drawStar(offsetX + cx*TILE_SIZE + TILE_SIZE/2, offsetY + cy*TILE_SIZE + TILE_SIZE/2, 5, TILE_SIZE*0.8, TILE_SIZE*0.4, "#f1c40f");
                } else {
                    // 都市の影/縁
                    ctx.fillStyle = "rgba(0,0,0,0.5)";
                    ctx.beginPath();
                    ctx.arc(offsetX + cx*TILE_SIZE + TILE_SIZE/2, offsetY + cy*TILE_SIZE + TILE_SIZE/2, TILE_SIZE/2, 0, Math.PI*2);
                    ctx.fill();
                    
                    // 都市本体
                    ctx.fillStyle = "#fff";
                    ctx.beginPath();
                    ctx.arc(offsetX + cx*TILE_SIZE + TILE_SIZE/2, offsetY + cy*TILE_SIZE + TILE_SIZE/2, TILE_SIZE/3, 0, Math.PI*2);
                    ctx.fill();
                }
            });
        });

        // 国名の描画 (HOI4スタイル)
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        nations.forEach(n => {
            // 傀儡国の名前は非表示
            if (n.isPuppet) return;
            
            if (!n.isDead && n.tiles.length > 30) {
                // mapScaleが小さい（ズームアウトしている）ほど、フォントサイズを大きくして視認性を維持
                const baseSize = 10 / mapScale;
                const sizeBonus = Math.min(12 / mapScale, (n.tiles.length / 600) / mapScale);
                const fontSize = baseSize + sizeBonus;
                
                ctx.font = `bold ${fontSize}px "Yu Gothic", "SimHei", "Segoe UI", sans-serif`;

                const drawX = offsetX + n.centroid.x * TILE_SIZE;
                const drawY = offsetY + n.centroid.y * TILE_SIZE;
                
                // 文字の縁取り (厚め)
                ctx.strokeStyle = "rgba(0,0,0,0.8)";
                ctx.lineWidth = Math.max(3 / mapScale, 2);
                ctx.strokeText(n.name, drawX, drawY);
                
                // 文字本体
                ctx.fillStyle = n.color;
                ctx.fillText(n.name, drawX, drawY);
            }
        });

    }

    // 外枠
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 1;
    ctx.strokeRect(offsetX, offsetY, width*TILE_SIZE, height*TILE_SIZE);

    ctx.restore();

    // HUD (Year / Tension)
    if (!isDrawing) {
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(10, 10, 120, 50);
        ctx.strokeStyle = "#4db8ff";
        ctx.lineWidth = 1;
        ctx.strokeRect(10, 10, 120, 50);

        ctx.fillStyle = "#fff";
        ctx.font = "bold 14px monospace";
        ctx.textAlign = "left";
        ctx.textBaseline = 'middle';
        ctx.fillText(`YEAR: ${year}`, 20, 25);
        ctx.fillStyle = worldTension > 50 ? "#ff6b6b" : "#4db8ff";
        ctx.fillText(`WT: ${worldTension.toFixed(1)}%`, 20, 45);
    }
}

function handlePolitics(n) {
    if (n.isDead) return;

    // 指導者の交代
    if (Math.random() < 0.005) {
        const oldLeader = n.leader;
        n.leader = n.generateLeaderName();
        const stabChange = Math.floor(Math.random() * 30) - 20; // -20 to +10
        n.stability = clamp(n.stability + stabChange, 0, 100);
        log(`${n.name}の指導者が${oldLeader}から${n.leader}に交代しました。(安定度: ${stabChange > 0 ? "+" : ""}${stabChange})`, "log-info");
    }

    // 王政国家向けのランダムイベント (共和派の台頭など)
    if ((n.govType === "絶対王政" || n.govType === "帝国") && Math.random() < 0.002) {
        const events = [
            { msg: "共和派の活動が活発化しています。", stab: -15 },
            { msg: "啓蒙思想が広まり、旧体制への不満が高まっています。", stab: -10 },
            { msg: "宮廷内での権力争いが発生しました。", stab: -12 }
        ];
        const event = events[Math.floor(Math.random() * events.length)];
        n.stability = clamp(n.stability + event.stab, 0, 100);
        log(`${n.name}: ${event.msg} (安定度: ${event.stab})`, "log-war");
    }

    // 安定度の自然変動
    if (n.atWarWith.length > 0) {
        n.stability -= 0.4;
    } else {
        n.stability = Math.min(100, n.stability + 0.5);
    }

    // 不満度の更新
    n.unrest = 100 - n.stability;

    // 都市ごとの不満度更新
    n.cities.forEach((city, idx) => {
        let cityUnrest = n.unrest + (Math.random() * 20 - 10);
        // 首都(index 0)からの距離による不満度増加
        if (idx > 0) {
            const capital = n.cities[0];
            const dx = (city.tileIdx % width) - (capital.tileIdx % width);
            const dy = Math.floor(city.tileIdx / width) - Math.floor(capital.tileIdx / width);
            const dist = Math.sqrt(dx*dx + dy*dy);
            cityUnrest += dist / 5;
        }
        city.unrest = clamp(cityUnrest, 0, 100);
    });

    // 反乱クールダウンの消化
    if (n.rebellionCooldown > 0) n.rebellionCooldown--;

    // 都市単位の内戦判定
    let rebellingCities = [];
    if (n.rebellionCooldown === 0 && n.cities.length > 0) {
        n.cities.forEach(city => {
            if (city.unrest > 75 && Math.random() < 0.005) {
                rebellingCities.push(city);
            }
        });
    }

    if (rebellingCities.length > 0) {
        // 周囲の不満が高い都市も誘い込む
        n.cities.forEach(city => {
            if (!rebellingCities.includes(city) && city.unrest > 50) {
                let isNear = rebellingCities.some(rc => {
                    const dx = (city.tileIdx % width) - (rc.tileIdx % width);
                    const dy = Math.floor(city.tileIdx / width) - Math.floor(rc.tileIdx / width);
                    return Math.sqrt(dx*dx + dy*dy) < 30;
                });
                if (isNear && Math.random() < 0.5) rebellingCities.push(city);
            }
        });
        triggerCityRebellion(n, rebellingCities);
    }

    // 政変の判定
    if (n.stability < 50 && Math.random() < 0.002) {
        const oldName = n.name;
        const oldGov = n.govType;
        n.govType = (Math.random() > 0.5) ? "独裁制" : "軍事政権";
        n.updateName();
        n.stability = Math.max(0, n.stability - 30);
        log(`${oldName}で政変が発生！ ${oldGov}から${n.govType}へ体制が変わり、${n.name}となりました。`, "log-war");
    }

    // 共和制への移行
    if (n.govType !== "共和制" && n.tech >= 3 && n.stability > 80 && Math.random() < 0.001) {
        const oldName = n.name;
        n.govType = "共和制";
        n.regimeNumber++;
        n.updateName();
        log(`${oldName}は近代化に伴い共和制へ移行し、${n.name}となりました。`, "log-peace");
    }

    // 平和的独立 (低確率)
    if (n.stability < 60 && n.cities.length > 2) {
        // 首都以外で不満が高い都市が対象
        const potentialCities = n.cities.filter((c, i) => i > 0 && c.unrest > 80);
        potentialCities.forEach(city => {
            if (Math.random() < 0.001) { // 非常に低確率
                grantIndependence(n, city);
            }
        });
    }

    // 反乱軍の正統化
    if (n.isRebel && n.stability > 70 && n.tiles.length > 25 && Math.random() < 0.01) {
        n.isRebel = false;
        const oldName = n.name;
        const newGovs = ["共和制", "帝国", "連邦制"];
        n.govType = newGovs[Math.floor(Math.random() * newGovs.length)];
        n.updateName();
        log(`${oldName}は安定した統治を確立し、${n.name}として国家の正統性を主張し始めました。`, "log-peace");
    }

    // 追い詰められた宗主国による緊急併合 (生存戦略)
    if (!n.isPuppet && (n.tiles.length < 15 || n.cities.length === 0) && !n.isDead) {
        const myPuppet = nations.find(p => p.isPuppet && p.masterId === n.id && !p.isDead);
        if (myPuppet) {
            // 全土併合
            log(`緊急事態: 追い詰められた${n.name}は、国家存続のために傀儡国である${myPuppet.name}を緊急併合しました！`, "log-war");
            
            // タイルの移動
            const puppetTiles = [...myPuppet.tiles];
            puppetTiles.forEach(tileIdx => {
                ownerGrid[tileIdx] = n.id;
                n.tiles.push(tileIdx);
            });
            myPuppet.tiles = [];

            // 都市の移動
            myPuppet.cities.forEach(city => {
                city.nationId = n.id;
                n.cities.push(city);
            });
            myPuppet.cities = [];

            // 傀儡国消滅
            myPuppet.isDead = true;
            myPuppet.pop = 0; // 人口も吸収すべきだが簡易的に0に
            
            // 安定度回復
            n.stability = Math.min(100, n.stability + 30);
        }
    }
}

function grantIndependence(n, city) {
    const newNation = new Nation();
    newNation.baseName = n.baseName;
    
    // 都市名を冠した国名
    const prefix = city.name.substring(0, city.name.length - 1); // "市"などを取る
    newNation.name = prefix + "共和国";
    newNation.govType = "共和国";
    newNation.color = `hsl(${Math.random()*360}, 60%, 60%)`;
    newNation.tech = n.tech;
    newNation.religion = n.religion;

    // 領土と都市の委譲
    const radius = 6;
    const cx = city.tileIdx % width;
    const cy = Math.floor(city.tileIdx / width);
    
    for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
            const nx = cx + dx;
            const ny = cy + dy;
            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                const idx = ny * width + nx;
                if (ownerGrid[idx] === n.id) {
                    ownerGrid[idx] = newNation.id;
                    newNation.tiles.push(idx);
                    n.tiles = n.tiles.filter(t => t !== idx);
                }
            }
        }
    }
    
    city.nationId = newNation.id;
    newNation.cities.push(city);
    n.cities = n.cities.filter(c => c !== city);

    // 人口・兵力の分配
    const ratio = 1 / (n.cities.length + 1); // 簡易計算
    newNation.pop = Math.floor(n.pop * ratio);
    n.pop = Math.max(0, n.pop - newNation.pop);
    newNation.soldiers = Math.floor(n.soldiers * ratio * 0.5); // 兵力は少なめ
    n.soldiers = Math.max(0, n.soldiers - newNation.soldiers);

    if (newNation.tiles.length > 0) {
        nations.push(newNation);
        
        // 良好な関係でスタート
        n.relations[newNation.id] = 50;
        newNation.relations[n.id] = 50;
        
        log(`平和的独立: ${n.name}から${city.name}が分離し、${newNation.name}として独立しました。`, "log-peace");
        
        // 安定度少し回復（厄介払いができたため）
        n.stability = Math.min(100, n.stability + 5);
    }
}

function triggerCityRebellion(n, cities) {
    // 反乱軍の生成
    const rebel = new Nation();
    rebel.baseName = n.baseName;
    rebel.parentName = n.baseName;
    rebel.isRebel = true;

    // かっこいい反乱軍の名称生成
    const rebelTypes = [
        { name: "臨時政府", gov: "臨時政府" },
        { name: "立憲派", gov: "革命政府" },
        { name: "正統政府", gov: "正統政府" },
        { name: "救国戦線", gov: "革命政府" },
        { name: "人民委員会", gov: "革命政府" }
    ];
    
    // 特別な名称: 共和国第n政 (親が共和国の場合)
    if (n.govType === "共和制" && Math.random() < 0.4) {
        rebel.govType = "共和制";
        rebel.regimeNumber = n.regimeNumber + 1;
        rebel.updateName();
    } else {
        const type = rebelTypes[Math.floor(Math.random() * rebelTypes.length)];
        rebel.govType = type.gov;
        // 都市名を冠した名称にする (最初の都市)
        const prefix = cities[0].name.substring(0, cities[0].name.length - 1);
        rebel.name = prefix + type.name;
    }

    rebel.rebellionCooldown = 200; // 初期無敵状態
    n.rebellionCooldown = 200; // 親国も一定期間再発防止
    rebel.color = `hsl(${Math.random()*360}, 80%, 40%)`;
    rebel.tech = n.tech;
    rebel.religion = n.religion;
    
    // 領土と都市の委譲
    cities.forEach(city => {
        const cityIdx = city.tileIdx;
        const cx = cityIdx % width;
        const cy = Math.floor(cityIdx / width);
        const radius = 6;
        
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const nx = cx + dx;
                const ny = cy + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    const idx = ny * width + nx;
                    if (ownerGrid[idx] === n.id) {
                        ownerGrid[idx] = rebel.id;
                        rebel.tiles.push(idx);
                        n.tiles = n.tiles.filter(t => t !== idx);
                    }
                }
            }
        }
        city.nationId = rebel.id;
        rebel.cities.push(city);
    });
    n.cities = n.cities.filter(c => !cities.includes(c));

    // 兵力と人口の分配
    const ratio = cities.length / (n.cities.length + cities.length);
    rebel.pop = Math.floor(n.pop * ratio);
    n.pop = Math.floor(n.pop - rebel.pop);
    rebel.soldiers = Math.floor(n.soldiers * ratio * 0.8);
    n.soldiers = Math.floor(n.soldiers - rebel.soldiers);

    if (rebel.tiles.length > 0) {
        nations.push(rebel);
        declareWar(n, rebel);
        log(`${n.name}で内戦が発生！ ${cities.map(c => c.name).join('、')}が${rebel.name}として蜂起しました。`, "log-war");
        n.stability = Math.max(0, n.stability - 20);
    }
}

function simulateTick() {
    let totalPop = 0;
    // 緊張感の自然減衰
    worldTension = Math.max(0, worldTension - 0.2);

    // 1. 内政フェーズ
    nations.forEach(n => {
        if (n.isDead) return;
        
        handlePolitics(n);

        // 都市の建設
        if (n.tiles.length > (n.cities.length + 1) * 50 && Math.random() < 0.05) {
            const potentialTiles = n.tiles.filter(t => !n.cities.some(c => c.tileIdx === t));
            if (potentialTiles.length > 0) {
                const newTile = potentialTiles[Math.floor(Math.random() * potentialTiles.length)];
                const cityName = n.generateCityName();
                n.cities.push(new City(cityName, newTile, n.id));
                log(`${n.name}が新たな都市「${cityName}」を建設しました。`, "log-info");
            }
        }

        // 人口増加: 領土面積と技術に基づくロジスティック回帰モデル
        let capacity = n.tiles.length * 1000 * (1 + n.tech * 0.5);
        let growth = 0.02 * (1 - n.pop / capacity);
        if (growth < -0.01) growth = -0.01; // 急激な減少を抑える
        n.pop = Math.floor(n.pop * (1 + growth));
        
        // GDP成長: 工業力と人口、技術（人口依存度を下げる）
        n.gdp += (n.industry * 2) + (n.pop * 0.002) * (1 + n.tech);
        
        // 軍備増強: GDPの一部を軍事費へ
        let milBudget = n.gdp * 0.1;
        if (n.atWarWith.length > 0) milBudget = n.gdp * 0.3; // 戦時体制

        // 兵士雇用 / 維持
        let desiredSoldiers = Math.floor(n.pop * 0.05); // 人口の5%が上限目安
        if (n.soldiers < desiredSoldiers && milBudget > 0) {
            n.soldiers += 10;
            milBudget -= 10;
        }
        
        // 技術発展 / 戦車製造
        if (n.gdp > 5000 && n.tech < 4 && Math.random() < 0.01) n.tech++;
        if (n.tech >= 2 && milBudget > 100) {
            n.tanks++;
            milBudget -= 50;
        }
        
        // 海軍建造 (技術レベル2以上かつ海岸線がある場合)
        if (n.tech >= 2 && milBudget > 150 && n.isCoastal()) {
            n.ships++;
            milBudget -= 100;
        }

        // 重心計算
        n.updateCentroid();

        totalPop += n.pop;
    });
    document.getElementById('info-pop').innerText = formatNum(totalPop);

    // 2. 外交フェーズ
    nations.forEach(n => {
        if (n.isDead) return;

        // 外交併合: 傀儡国を併合
        if (!n.isPuppet) {
            const myPuppets = nations.filter(p => p.isPuppet && p.masterId === n.id && !p.isDead);
            myPuppets.forEach(p => {
                // 10年以上経過かつ宗主国の安定度が高い場合
                if (year - p.puppetSince > 10 && n.stability > 70 && Math.random() < 0.005) {
                    log(`外交併合: ${n.name}は長年の属国である${p.name}を完全に併合しました。`, "log-peace");
                    
                    // 領土統合
                    const pTiles = [...p.tiles];
                    pTiles.forEach(t => {
                        ownerGrid[t] = n.id;
                        n.tiles.push(t);
                    });
                    p.tiles = [];
                    
                    // 都市統合
                    p.cities.forEach(c => {
                        c.nationId = n.id;
                        n.cities.push(c);
                    });
                    p.cities = [];

                    p.isDead = true;
                    p.pop = 0;
                    n.stability = Math.min(100, n.stability + 10);
                }
            });
        }
        
        // ランダムな対象国を選ぶ (頻度向上)
        const target = nations[Math.floor(Math.random() * nations.length)];
        if (target.id === n.id || target.isDead) return;

        // 関係値初期化
        if (n.relations[target.id] === undefined) n.relations[target.id] = 0;

        // 関係変動要因 (より過激に)
        let change = (Math.random() - 0.5) * 5; 
        if (n.religion === target.religion) change += 5;
        else change -= 5;

        // 世界の緊張感による悪化
        change -= (worldTension / 10);
        
        // 隣接していると摩擦が非常に起きやすい
        let neighbor = isNeighbor(n, target);
        if (neighbor) change -= 10;

        // ボーダーインシデント (突発的な悪化)
        if (neighbor && Math.random() < 0.05) {
            change -= 40;
            log(`偶発的衝突: ${n.name}と${target.name}の間で緊張が高まっています！`, "log-war");
        }

        n.relations[target.id] = clamp(n.relations[target.id] + change, -100, 100);

        // 戦争判定 (閾値を下げ、好戦的に)
        if (n.relations[target.id] < -50 && neighbor) {
            if (!n.atWarWith.includes(target.id)) {
                // 傀儡国は主人に逆らわない
                if (n.isPuppet && n.masterId === target.id) return;
                // 主人は傀儡国を攻撃しない
                if (target.isPuppet && target.masterId === n.id) return;
                declareWar(n, target);
            }
        }

        // 野心による開戦 (圧倒的有利な場合)
        if (neighbor && n.getMilitaryPower() > target.getMilitaryPower() * 2 && Math.random() < 0.05) {
            if (!n.atWarWith.includes(target.id)) {
                // 傀儡国は主人に逆らわない
                if (n.isPuppet && n.masterId === target.id) return;
                // 主人は傀儡国を攻撃しない
                if (target.isPuppet && target.masterId === n.id) return;
                log(`野心: ${n.name}は${target.name}への領土拡大の好機を見出しました！`, "log-war");
                declareWar(n, target);
            }
        }
        // 和平判定
        else if (n.atWarWith.includes(target.id)) {
            let peaceChance = 0.005; // 基礎和平確率
            if (n.relations[target.id] > -20) peaceChance += 0.02;
            
            // 地形による和平確率の上昇 (山や川が境界だと膠着しやすい)
            const comp = getBoundaryComposition(n, target);
            let roughTerrainRatio = 0;
            if (comp.total > 0) {
                roughTerrainRatio = (comp.mountain + comp.river) / comp.total;
                if (roughTerrainRatio > 0.4) {
                    peaceChance += 0.05; // 境界の40%以上が険しい地形で和平しやすくなる
                }
            }

            if (Math.random() < peaceChance) {
                // 終戦形式の決定
                const nPow = n.getMilitaryPower();
                const tPow = target.getMilitaryPower();
                const ratio = nPow / tPow;

                if (ratio > 5 || ratio < 0.2) {
                    // 一方が圧倒的
                    const loser = ratio > 5 ? target : n;
                    if (loser.stability < 40 || loser.cities.length <= 2) {
                        concludePeace(n, target, 'PUPPET');
                    } else {
                        concludePeace(n, target, 'PARTIAL_PEACE');
                    }
                } else if (ratio > 2.5 || ratio < 0.4) {
                    // 優勢 -> 国境割譲 または 都市割譲
                    if (Math.random() < 0.6) {
                        concludePeace(n, target, 'ANNEX_BORDER');
                    } else {
                        concludePeace(n, target, 'PARTIAL_PEACE');
                    }
                } else if (roughTerrainRatio > 0.6) {
                    // 地形による膠着
                    concludePeace(n, target, 'WHITE_PEACE');
                } else {
                    concludePeace(n, target, 'DEFAULT');
                }
            }
        }
    });

    // 3. 戦争フェーズ
    nations.forEach(attacker => {
        if (attacker.isDead) return;
        
        attacker.atWarWith.forEach(enemyId => {
            const defender = nations.find(n => n.id === enemyId);
            if (!defender || defender.isDead) return;

            // 戦闘処理
            if (isNeighbor(attacker, defender)) {
                battle(attacker, defender);
            } else {
                // 非隣接国への上陸作戦
                if (attacker.tech >= 2 && Math.random() < 0.1) {
                    navalLanding(attacker, defender);
                }
            }
        });
    });
    
    // 滅亡判定
    nations.forEach(n => {
        if (!n.isDead && n.tiles.length === 0) {
            n.isDead = true;
            log(`${n.name}が滅亡しました！`, "log-war");
            // 戦争状態解除
            nations.forEach(other => {
                other.atWarWith = other.atWarWith.filter(id => id !== n.id);
            });
        }
    });
}

function isNeighbor(n1, n2) {
    // 重いので簡易判定: 領土の中心距離などではなく、実際のグリッド走査は重すぎる。
    // ここでは「戦争中なら強制的に接触ありとみなす」または簡易的なランダムチェック
    // 正確にするなら境界線リストを持つべきだが、今回はランダムピックで代用
    for(let i=0; i<50; i++) {
        let tile = n1.tiles[Math.floor(Math.random() * n1.tiles.length)];
        if (tile === undefined) continue;
        let cx = tile % width;
        let cy = Math.floor(tile / width);
        let found = false;
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
            let nx=cx+dx, ny=cy+dy;
            if(nx>=0 && nx<width && ny>=0 && ny<height) {
                let nIdx = ny*width+nx;
                if(ownerGrid[nIdx] === n2.id) found = true;
            }
        });
        if(found) return true;
    }
    return false;
}

/**
 * 境界線の地形構成を取得
 */
function getBoundaryComposition(n1, n2) {
    let counts = {mountain: 0, river: 0, total: 0};
    const samples = Math.min(n1.tiles.length, 100);
    for(let i=0; i<samples; i++) {
        let tile = n1.tiles[Math.floor(Math.random() * n1.tiles.length)];
        if (tile === undefined) continue;
        let cx = tile % width;
        let cy = Math.floor(tile / width);
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
            let nx=cx+dx, ny=cy+dy;
            if(nx>=0 && nx<width && ny>=0 && ny<height) {
                let nIdx = ny*width+nx;
                if(ownerGrid[nIdx] === n2.id) {
                    counts.total++;
                    const type = grid[nIdx];
                    if (type === 2) counts.mountain++;
                    else if (type === 3) counts.river++;
                }
            }
        });
    }
    return counts;
}

function declareWar(n1, n2) {
    if(n1.atWarWith.includes(n2.id)) return;
    n1.atWarWith.push(n2.id);
    if(!n2.atWarWith.includes(n1.id)) n2.atWarWith.push(n1.id);
    worldTension = Math.min(100, worldTension + 5);
    log(`戦争: ${n1.name}が${n2.name}に宣戦布告しました！（緊張度: ${worldTension.toFixed(1)}%）`, "log-war");

    // 宗主国による防衛
    if (n2.isPuppet && n2.masterId !== -1) {
        const master = nations.find(m => m.id === n2.masterId);
        if (master && !master.isDead && master.id !== n1.id) {
            if (!master.atWarWith.includes(n1.id)) {
                 log(`${n2.name}の宗主国である${master.name}が保護義務を履行し、参戦しました。`, "log-war");
                 declareWar(master, n1);
            }
        }
    }

    // 傀儡国も参戦
    nations.forEach(puppet => {
        if (puppet.isPuppet && puppet.masterId === n1.id && !puppet.isDead) {
            if (!puppet.atWarWith.includes(n2.id)) {
                puppet.atWarWith.push(n2.id);
                if (!n2.atWarWith.includes(puppet.id)) n2.atWarWith.push(puppet.id);
                log(`${n1.name}の傀儡国、${puppet.name}が参戦しました。`, "log-war");
            }
        }
        if (puppet.isPuppet && puppet.masterId === n2.id && !puppet.isDead) {
            if (!puppet.atWarWith.includes(n1.id)) {
                puppet.atWarWith.push(n1.id);
                if (!n1.atWarWith.includes(puppet.id)) n1.atWarWith.push(puppet.id);
                log(`${n2.name}の傀儡国、${puppet.name}が参戦しました。`, "log-war");
            }
        }
    });
}

function concludePeace(n1, n2, type) {
    // Determine winner/loser if applicable
    let winner = n1, loser = n2;
    if (n2.getMilitaryPower() > n1.getMilitaryPower()) {
        winner = n2;
        loser = n1;
    }

    n1.atWarWith = n1.atWarWith.filter(id => id !== n2.id);
    n2.atWarWith = n2.atWarWith.filter(id => id !== n1.id);

    if (type === 'WHITE_PEACE') {
        log(`白紙講和: ${n1.name}と${n2.name}が現状維持で停戦しました。`, "log-peace");
    } else if (type === 'PARTIAL_PEACE') {
        // Transfer some cities as a condition
        // 勝者の本国に近い都市を優先的に割譲させる
        const numCitiesToTransfer = Math.min(loser.cities.length - 1, 2);
        
        if (numCitiesToTransfer > 0) {
            // 距離計算用ヘルパー
            const getDist = (c1, c2) => {
                const dx = (c1.tileIdx % width) - c2.x;
                const dy = Math.floor(c1.tileIdx / width) - c2.y;
                return dx*dx + dy*dy;
            };

            // 勝者の重心に近い順にソート
            const sortedCities = [...loser.cities].sort((a, b) => {
                return getDist(a, winner.centroid) - getDist(b, winner.centroid);
            });

            const citiesToTake = sortedCities.slice(0, numCitiesToTransfer);

            citiesToTake.forEach(city => {
                // loser.citiesから削除
                loser.cities = loser.cities.filter(c => c !== city);
                
                city.nationId = winner.id;
                winner.cities.push(city);
                
                // 周辺タイルの譲渡
                const cx = city.tileIdx % width;
                const cy = Math.floor(city.tileIdx / width);
                const radius = 5;
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const nx = cx + dx;
                        const ny = cy + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const idx = ny * width + nx;
                            if (ownerGrid[idx] === loser.id) {
                                ownerGrid[idx] = winner.id;
                                winner.tiles.push(idx);
                                loser.tiles = loser.tiles.filter(t => t !== idx);
                            }
                        }
                    }
                }
            });
            log(`途中講和: ${loser.name}が領土を割譲し、${winner.name}と和平しました。`, "log-peace");
        } else {
            log(`和平: ${n1.name}と${n2.name}が停戦合意しました。`, "log-peace");
        }
    } else if (type === 'ANNEX_BORDER') {
        // 国境地帯の割譲 (約20%)
        const targetCount = Math.floor(loser.tiles.length * 0.2);
        
        // 1. 直接接触しているタイルを特定
        let borderTiles = [];
        for(const tIdx of loser.tiles) {
            const cx = tIdx % width;
            const cy = Math.floor(tIdx / width);
            let isBorder = false;
            const neighbors = [[0,1],[0,-1],[1,0],[-1,0]];
            for(const [dx, dy] of neighbors) {
                let nx=cx+dx, ny=cy+dy;
                if(nx>=0 && nx<width && ny>=0 && ny<height) {
                    let nIdx = ny*width+nx;
                    if(ownerGrid[nIdx] === winner.id) {
                        isBorder = true;
                        break;
                    }
                }
            }
            if(isBorder) borderTiles.push(tIdx);
        }

        if (borderTiles.length > 0) {
            const queue = [...borderTiles];
            const takenSet = new Set(borderTiles);
            
            let head = 0;
            while(head < queue.length && takenSet.size < targetCount) {
                const curr = queue[head++];
                const cx = curr % width;
                const cy = Math.floor(curr / width);

                const neighbors = [[0,1],[0,-1],[1,0],[-1,0]];
                for(const [dx, dy] of neighbors) {
                    let nx=cx+dx, ny=cy+dy;
                    if(nx>=0 && nx<width && ny>=0 && ny<height) {
                        let nIdx = ny*width+nx;
                        if(ownerGrid[nIdx] === loser.id && !takenSet.has(nIdx)) {
                            takenSet.add(nIdx);
                            queue.push(nIdx);
                        }
                    }
                }
            }

            // 領土移譲
            takenSet.forEach(tIdx => {
                ownerGrid[tIdx] = winner.id;
                winner.tiles.push(tIdx);
            });
            loser.tiles = loser.tiles.filter(t => !takenSet.has(t));

            // 都市移譲
            for(let i=loser.cities.length-1; i>=0; i--) {
                const city = loser.cities[i];
                if(ownerGrid[city.tileIdx] === winner.id) {
                    city.nationId = winner.id;
                    winner.cities.push(city);
                    loser.cities.splice(i, 1);
                }
            }
            log(`国境割譲: ${loser.name}は国境地帯を${winner.name}に割譲しました。`, "log-peace");
        } else {
             log(`和平: ${n1.name}と${n2.name}が停戦合意しました。`, "log-peace");
        }

    } else if (type === 'PUPPET') {
        // 傀儡化時に領土の2/3を宗主国が吸収するが、綺麗な国境にするために
        // 敗戦国の首都を中心に約1/3の領土を残し、残りを割譲させる (BFS)
        const totalTiles = loser.tiles.length;
        const targetKeep = Math.ceil(totalTiles / 3);
        
        // 首都または最初のタイルを起点にする
        let startTile = -1;
        if (loser.cities.length > 0) {
            startTile = loser.cities[0].tileIdx;
        } else if (loser.tiles.length > 0) {
            startTile = loser.tiles[0];
        }

        const keepSet = new Set();
        if (startTile !== -1) {
            const queue = [startTile];
            keepSet.add(startTile);

            let head = 0;
            while(head < queue.length && keepSet.size < targetKeep) {
                const curr = queue[head++];
                const cx = curr % width;
                const cy = Math.floor(curr / width);

                const neighbors = [
                    [cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]
                ];

                for(const [nx, ny] of neighbors) {
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        const nIdx = ny * width + nx;
                        // 自分の領土かつ未訪問なら追加
                        if (ownerGrid[nIdx] === loser.id && !keepSet.has(nIdx)) {
                            keepSet.add(nIdx);
                            queue.push(nIdx);
                            if (keepSet.size >= targetKeep) break;
                        }
                    }
                }
            }
        }

        // keepSetに含まれない領土をすべて勝者に移譲
        const originalTiles = [...loser.tiles];
        loser.tiles = []; // 一旦クリアして再構築

        originalTiles.forEach(tIdx => {
            if (keepSet.has(tIdx)) {
                loser.tiles.push(tIdx);
            } else {
                ownerGrid[tIdx] = winner.id;
                winner.tiles.push(tIdx);
            }
        });

        // 都市の委譲判定
        for(let i=loser.cities.length-1; i>=0; i--) {
            const city = loser.cities[i];
            if(ownerGrid[city.tileIdx] === winner.id) {
                city.nationId = winner.id;
                winner.cities.push(city);
                loser.cities.splice(i, 1);
            }
        }

        loser.isPuppet = true;
        loser.masterId = winner.id;
        loser.puppetSince = year;
        loser.updateName();
        loser.stability = 50;
        winner.relations[loser.id] = 100;
        loser.relations[winner.id] = 100;
        
        // 敗戦国の傀儡国を戦勝国へ委譲
        nations.forEach(vassal => {
            if (vassal.isPuppet && vassal.masterId === loser.id && !vassal.isDead) {
                vassal.masterId = winner.id;
                // 名前更新は不要かもしれないが、念のため
                vassal.updateName();
                log(`戦勝国による処分: ${vassal.name}の宗主権が${winner.name}に移譲されました。`, "log-war");
            }
        });

        log(`戦後処理: ${loser.name}は${winner.name}の傀儡国となりました。`, "log-war");
    } else {
        log(`和平: ${n1.name}と${n2.name}が停戦合意しました。`, "log-peace");
    }
}

function makePeace(n1, n2) {
    concludePeace(n1, n2, 'DEFAULT');
}

function battle(attacker, defender) {
    // 攻撃側のパワー vs 防御側のパワー + 地形ボーナス
    const atkPow = attacker.getMilitaryPower() * (0.8 + Math.random()*0.4);
    const defPow = defender.getMilitaryPower() * (0.8 + Math.random()*0.4); // 防御有利なしの消耗戦

    // どちらかが領土を奪う
    // 攻撃側が圧倒的に強い場合
    if (atkPow > defPow * 1.5) {
        // 圧倒的勝利: 3タイル奪う
        stealTerritory(attacker, defender);
        stealTerritory(attacker, defender);
        stealTerritory(attacker, defender);
        defender.soldiers = Math.max(0, Math.floor(defender.soldiers * 0.9));
    } else if (atkPow > defPow * 1.1) {
        stealTerritory(attacker, defender);
        // 敗者は兵を失う
        defender.soldiers = Math.max(0, Math.floor(defender.soldiers * 0.95));
    } else {
        // 攻撃失敗、兵を失う
        attacker.soldiers = Math.max(0, Math.floor(attacker.soldiers * 0.98));
    }
}

function navalLanding(attacker, defender) {
    if (!attacker.isCoastal() || !defender.isCoastal()) return;
    if (attacker.ships < 5) return; // ある程度の海軍力が必要

    const atkNaval = attacker.getNavalPower() * (0.8 + Math.random()*0.4);
    const defNaval = defender.getNavalPower() * (0.8 + Math.random()*0.4);

    if (atkNaval > defNaval) {
        // 上陸成功: 敵の海岸タイルを1つ奪う
        stealCoastalTerritory(attacker, defender);
        attacker.ships = Math.max(0, Math.floor(attacker.ships * 0.95)); // 消耗
    } else {
        // 上陸失敗: 海軍力消耗
        attacker.ships = Math.max(0, Math.floor(attacker.ships * 0.8));
    }
}

function stealCoastalTerritory(winner, loser) {
    // 1. 沿岸都市の奪取を優先
    const coastalCities = loser.cities.filter(city => {
        const cx = city.tileIdx % width;
        const cy = Math.floor(city.tileIdx / width);
        let isCoast = false;
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
            let nx=cx+dx, ny=cy+dy;
            if(nx>=0 && nx<width && ny>=0 && ny<height && grid[ny*width+nx] === 0) isCoast = true;
        });
        return isCoast;
    });

    if (coastalCities.length > 0 && Math.random() < 0.5) {
        const targetCity = coastalCities[Math.floor(Math.random() * coastalCities.length)];
        const cx = targetCity.tileIdx % width;
        const cy = Math.floor(targetCity.tileIdx / width);
        const radius = 4;
        
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const nx = cx + dx;
                const ny = cy + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    const idx = ny * width + nx;
                    if (ownerGrid[idx] === loser.id) {
                        ownerGrid[idx] = winner.id;
                        winner.tiles.push(idx);
                        loser.tiles = loser.tiles.filter(t => t !== idx);
                    }
                }
            }
        }
        targetCity.nationId = winner.id;
        winner.cities.push(targetCity);
        loser.cities = loser.cities.filter(c => c !== targetCity);
        loser.stability -= 15;
        log(`海軍作戦: ${winner.name}が${loser.name}の沿岸都市「${targetCity.name}」を占拠しました！`, "log-war");
        return;
    }

    // 2. 失敗した場合は通常の沿岸タイルを奪う
    for(let i=0; i<100; i++) {
        let tile = loser.tiles[Math.floor(Math.random() * loser.tiles.length)];
        let cx = tile % width;
        let cy = Math.floor(tile / width);
        
        let isCoast = false;
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
            let nx=cx+dx, ny=cy+dy;
            if(nx>=0 && nx<width && ny>=0 && ny<height) {
                if(grid[ny*width+nx] === 0) isCoast = true;
            }
        });

        if (isCoast) {
            ownerGrid[tile] = winner.id;
            winner.tiles.push(tile);
            loser.tiles = loser.tiles.filter(t => t !== tile);
            loser.stability -= 5;
            log(`海軍作戦: ${winner.name}が${loser.name}への上陸作戦に成功しました！`, "log-war");
            return;
        }
    }
}

function stealTerritory(winner, loser) {
    // 敗者の領土のうち、勝者と接しているタイルを1つ奪う
    // 計算量削減のため、ランダムサンプリングで境界を探す
    for(let i=0; i<20; i++) {
        let tile = winner.tiles[Math.floor(Math.random() * winner.tiles.length)];
        let cx = tile % width;
        let cy = Math.floor(tile / width);
        
        let targetIdx = -1;
        // 隣接する敗者タイルを探す
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
            let nx=cx+dx, ny=cy+dy;
            if(nx>=0 && nx<width && ny>=0 && ny<height) {
                let idx = ny*width+nx;
                if(ownerGrid[idx] === loser.id) targetIdx = idx;
            }
        });

        if (targetIdx !== -1) {
            // 地形による進軍速度の変動
            const terrain = grid[targetIdx];
            let difficulty = 1;
            if (terrain === 2) difficulty = 4; // 山岳: 1/4の確率
            if (terrain === 3) difficulty = 2; // 河川: 1/2の確率
            
            if (Math.random() > (1 / difficulty)) return; // 失敗（進軍停止）

            // 領土移動処理
            ownerGrid[targetIdx] = winner.id;
            winner.tiles.push(targetIdx);
            loser.tiles = loser.tiles.filter(t => t !== targetIdx);

            loser.stability -= 5;

            // Aggressive Expansion: 他国との関係悪化
            nations.forEach(other => {
                if (other.id !== winner.id && !other.isDead) {
                    if (winner.relations[other.id] !== undefined) {
                        winner.relations[other.id] -= 1; // 小さな蓄積
                    }
                }
            });
            worldTension = Math.min(100, worldTension + 0.1);

            return; // 1ターン1タイルのみ
        }
    }
}

/**
 * UI & Utility
 */
function updateNationPanel() {
    if (selectedNationId === -1) return;
    const n = nations.find(nat => nat.id === selectedNationId);
    if (!n) return;

    document.getElementById('n-name').innerText = n.name + (n.isDead ? " (滅亡)" : "");
    document.getElementById('n-name').style.color = n.color;
    document.getElementById('n-leader').innerText = n.leader;
    document.getElementById('n-gov').innerText = n.govType;
    document.getElementById('n-religion').innerText = n.religion;
    document.getElementById('n-tech').innerText = TECH_LEVELS[n.tech];
    document.getElementById('n-stability').innerText = Math.floor(n.stability) + "%";
    
    document.getElementById('n-gdp').innerText = formatNum(n.gdp);
    document.getElementById('bar-gdp').style.width = Math.min(100, n.gdp / 1000) + "%";
    
    document.getElementById('n-pop').innerText = formatNum(n.pop);
    document.getElementById('bar-pop').style.width = Math.min(100, n.pop / 50000) + "%";
    
    document.getElementById('n-mil').innerText = formatNum(n.soldiers);
    document.getElementById('bar-mil').style.width = Math.min(100, n.soldiers / 5000) + "%";
    
    document.getElementById('n-ind').innerText = n.industry;
    document.getElementById('n-tanks').innerText = n.tanks;
    document.getElementById('n-ships').innerText = n.ships;
    document.getElementById('n-qual').innerText = n.soldierQuality.toFixed(2);
}

function log(msg, className) {
    const logEl = document.getElementById('log');
    const line = document.createElement('div');
    line.innerText = `[Y${year}] ${msg}`;
    if (className) line.className = className;
    logEl.prepend(line);
    if (logEl.children.length > 50) logEl.lastChild.remove();
}

function formatNum(num) {
    if (num >= 100000000) return (num/100000000).toFixed(1) + "億";
    if (num >= 10000) return (num/10000).toFixed(1) + "万";
    return Math.floor(num);
}

function clamp(val, min, max) {
    return Math.min(Math.max(val, min), max);
}

function drawStar(cx, cy, spikes, outerRadius, innerRadius, color) {
    let rot = Math.PI / 2 * 3;
    let x = cx;
    let y = cy;
    let step = Math.PI / spikes;

    ctx.beginPath();
    ctx.moveTo(cx, cy - outerRadius)
    for (let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius;
        y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y)
        rot += step

        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y)
        rot += step
    }
    ctx.lineTo(cx, cy - outerRadius)
    ctx.closePath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'black';
    ctx.stroke();
    ctx.fillStyle = color;
    ctx.fill();
}

</script>
</body>
</html>
