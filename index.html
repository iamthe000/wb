<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ファンタジー世界シミュレーター</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0c0c0c; color: #e0e0e0; font-family: 'Segoe UI', 'Roboto', sans-serif; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; cursor: crosshair; background: #000; }
        canvas { display: block; image-rendering: pixelated; }
        #sidebar { width: 320px; background: #1a1a1a; padding: 20px; overflow-y: auto; box-shadow: -2px 0 10px rgba(0,0,0,0.8); display: flex; flex-direction: column; gap: 15px; border-left: 1px solid #333; }

        @media (max-width: 768px) {
            #container { flex-direction: column; }
            #sidebar { width: 100%; height: 40vh; border-left: none; border-top: 1px solid #333; box-sizing: border-box; }
            #canvas-container { height: 60vh; }
        }
        
        h1, h2 { margin: 0 0 10px 0; color: #ccc; text-transform: uppercase; letter-spacing: 2px; font-weight: 300; }
        h1 { font-size: 1.4em; border-bottom: 1px solid #555; padding-bottom: 8px; color: #4db8ff; }
        .panel { background: #222; padding: 15px; border-radius: 0; border: 1px solid #444; margin-bottom: 10px; }
        button { background: #34495e; border: 1px solid #5d6d7e; padding: 10px; color: #ecf0f1; font-weight: bold; cursor: pointer; width: 100%; margin-top: 5px; transition: 0.2s; }
        button:hover { background: #4db8ff; color: #000; }
        button:disabled { background: #666; cursor: not-allowed; }
        
        .stat-row { display: flex; justify-content: space-between; font-size: 0.9em; margin-bottom: 3px; }
        .bar-bg { background: #222; height: 6px; border-radius: 3px; overflow: hidden; margin-bottom: 8px; }
        .bar-fill { height: 100%; background: #ccc; }
        
        #log { font-size: 0.8em; height: 150px; overflow-y: auto; background: #111; padding: 5px; font-family: monospace; border: 1px solid #555; }
        .log-war { color: #ff6b6b; }
        .log-peace { color: #51cf66; }
        .log-info { color: #aaa; }
        
        /* Tooltip style overlay */
        #hover-info { position: absolute; background: rgba(0,0,0,0.8); padding: 5px; pointer-events: none; border-radius: 4px; display: none; font-size: 0.8em; z-index: 10; border: 1px solid #666; }
    </style>
</head>
<body>

<div id="container">
    <div id="canvas-container">
        <canvas id="gameCanvas"></canvas>
        <div id="hover-info"></div>
    </div>
    
    <div id="sidebar">
        <h1>世界シミュレーター</h1>
        
        <div id="menu-panel" class="panel">
            <h2>1. マップデザイン</h2>
            <p>左クリック/タッチ: 描画 (右クリックで消去)</p>
            <button id="btn-brush" style="margin-bottom:10px;">ブラシ: 陸地</button>
            <div>
                サイズ: <select id="mapSize">
                    <option value="64">小 (64x64)</option>
                    <option value="128" selected>中 (128x128)</option>
                    <option value="256">大 (256x256)</option>
                </select>
            </div>
            <button id="btn-fill" style="margin-bottom:10px;">塗りつぶしモード: オフ</button>
            <button id="btn-generate">世界を生成 (シミュレーション開始)</button>
        </div>

        <div id="sim-panel" class="panel" style="display:none;">
            <h2>2. 世界情勢</h2>
            <div class="stat-row"><span>年:</span> <span id="info-year">1</span></div>
            <div class="stat-row"><span>総人口:</span> <span id="info-pop">0</span></div>
            <div class="stat-row"><span>緊張度:</span> <span id="info-tension">0%</span></div>
            <div class="stat-row"><span>速度:</span> <input type="range" id="simSpeed" min="1" max="10" value="5" style="width:100px;"></div>
            <button id="btn-pause">一時停止 / 再開</button>
        </div>

        <div id="nation-panel" class="panel" style="display:none;">
            <h2 id="n-name">国家名</h2>
            <div class="stat-row"><span>指導者:</span> <span id="n-leader"></span></div>
            <div class="stat-row"><span>体制:</span> <span id="n-gov"></span></div>
            <div class="stat-row"><span>宗教:</span> <span id="n-religion"></span></div>
            <div class="stat-row"><span>技術:</span> <span id="n-tech"></span></div>
            <div class="stat-row"><span>安定度:</span> <span id="n-stability"></span></div>
            
            <hr style="border-color:#555">
            
            <div class="stat-row"><span>国内総生産(GDP):</span> <span id="n-gdp"></span></div>
            <div class="bar-bg"><div id="bar-gdp" class="bar-fill" style="width:0; background:#f1c40f"></div></div>
            
            <div class="stat-row"><span>人口:</span> <span id="n-pop"></span></div>
            <div class="bar-bg"><div id="bar-pop" class="bar-fill" style="width:0; background:#2ecc71"></div></div>
            
            <div class="stat-row"><span>軍事力:</span> <span id="n-mil"></span></div>
            <div class="bar-bg"><div id="bar-mil" class="bar-fill" style="width:0; background:#e74c3c"></div></div>

            <div class="stat-row"><span>工業力:</span> <span id="n-ind"></span></div>
            <div class="stat-row"><span>戦車数:</span> <span id="n-tanks"></span></div>
            <div class="stat-row"><span>海軍力:</span> <span id="n-ships"></span></div>
            <div class="stat-row"><span>軍の質:</span> <span id="n-qual"></span></div>
        </div>

        <div class="panel">
            <h2>イベントログ</h2>
            <div id="log"></div>
        </div>
    </div>
</div>

<script>
/**
 * 定数と設定
 */
const TILE_SIZE = 6; // 描画時の1タイルのピクセルサイズ
const COLORS = {
    WATER: '#1a2a3a',
    LAND: '#3c4d3c',
    MOUNTAIN: '#4a4a4a',
    RIVER: '#2980b9',
    SNOW: '#ecf0f1'
};
const RELIGIONS = ['太陽神教', '海霊信仰', '機械崇拝', '自然の秩序', '混沌', '虚無'];
const TECH_LEVELS = ['原始的', '農耕社会', '工業化', '現代的', '未来的'];

// グローバル変数
let canvas, ctx, width, height;
let grid = []; // 0:Water, 1:Land, 2:Mountain, 3:River
let ownerGrid = []; // ID of the nation owning this tile (-1 for none)
let nations = [];
let nationIdCounter = 0;
let isDrawing = true;
let isFillMode = false;
let currentBrush = 1; // 1:Land, 0:Water
let mapScale = 1.0;
let isPaused = true;
let simSpeed = 5;
let frameCounter = 0;
let worldTension = 0;
let year = 1;
let animationFrame;
let selectedNationId = -1;

// マウス操作用
let mousePressed = false;
let mouseButton = 0; // 0:Left, 2:Right

/**
 * 初期化
 */
window.onload = () => {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    
    // キャンバスサイズ調整
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // グリッド初期化 (中サイズデフォルト)
    initGrid(128);

    // イベントリスナー
    setupInput();
    
    // ループ開始
    loop();
};

function resizeCanvas() {
    const container = document.getElementById('canvas-container');
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
}

function initGrid(size) {
    width = size;
    height = size;
    grid = new Array(width * height).fill(0);
    ownerGrid = new Array(width * height).fill(-1);
    nations = [];
    isDrawing = true;
    year = 1;
    document.getElementById('log').innerHTML = '';
}

/**
 * 入力処理
 */
function setupInput() {
    // 描画ツール
    canvas.addEventListener('mousedown', e => {
        mousePressed = true;
        mouseButton = e.button;
        handleDraw(e);
        handleSelect(e);
    });
    canvas.addEventListener('mousemove', e => {
        handleDraw(e);
        handleHover(e);
    });
    window.addEventListener('mouseup', () => mousePressed = false);

    // タッチ操作対応
    canvas.addEventListener('touchstart', e => {
        mousePressed = true;
        mouseButton = 0; // タッチは左クリック扱い
        handleDraw(e);
        handleSelect(e);
        e.preventDefault();
    }, { passive: false });
    canvas.addEventListener('touchmove', e => {
        handleDraw(e);
        handleHover(e);
        e.preventDefault();
    }, { passive: false });
    canvas.addEventListener('touchend', () => {
        mousePressed = false;
    });
    
    // 右クリックメニュー無効化
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // UIボタン
    document.getElementById('mapSize').addEventListener('change', (e) => {
        initGrid(parseInt(e.target.value));
    });

    document.getElementById('btn-generate').addEventListener('click', () => {
        generateWorld();
    });

    document.getElementById('btn-pause').addEventListener('click', () => {
        isPaused = !isPaused;
    });

    document.getElementById('simSpeed').addEventListener('input', (e) => {
        simSpeed = parseInt(e.target.value);
    });

    document.getElementById('btn-fill').addEventListener('click', (e) => {
        isFillMode = !isFillMode;
        e.target.innerText = `塗りつぶしモード: ${isFillMode ? 'オン' : 'オフ'}`;
        e.target.style.background = isFillMode ? '#4db8ff' : '#34495e';
        e.target.style.color = isFillMode ? '#000' : '#ecf0f1';
    });

    document.getElementById('btn-brush').addEventListener('click', (e) => {
        currentBrush = currentBrush === 1 ? 0 : 1;
        e.target.innerText = `ブラシ: ${currentBrush === 1 ? '陸地' : '海'}`;
        e.target.style.background = currentBrush === 1 ? '#34495e' : '#2980b9';
    });
}

/**
 * 描画モードの処理
 */
function handleDraw(e) {
    if (!mousePressed || !isDrawing) return;
    
    const {x, y} = getGridPos(e);

    if (x >= 0 && x < width && y >= 0 && y < height) {
        const targetType = (e.type.startsWith('touch') || mouseButton === 0) ? currentBrush : (currentBrush === 1 ? 0 : 1);
        
        if (isFillMode) {
            // 塗りつぶし（クリックした瞬間のみ実行したいが、mousedownでも呼ばれるのでOK）
            // mousemove中に塗りつぶしを連打すると重いので、mousedownの時だけにする工夫が必要
            if (e.type === 'mousedown' || e.type === 'touchstart') {
                floodFill(x, y, targetType);
            }
        } else {
            // ブラシサイズ（少し太く）
            for(let dy=-1; dy<=1; dy++){
                for(let dx=-1; dx<=1; dx++){
                    const nx = x+dx;
                    const ny = y+dy;
                    if(nx>=0 && nx<width && ny>=0 && ny<height){
                        const idx = ny * width + nx;
                        grid[idx] = targetType;
                    }
                }
            }
        }
    }
}

function floodFill(startX, startY, newType) {
    const oldType = grid[startY * width + startX];
    if (oldType === newType) return;

    const stack = [[startX, startY]];
    while (stack.length > 0) {
        const [x, y] = stack.pop();
        const idx = y * width + x;

        if (grid[idx] === oldType) {
            grid[idx] = newType;

            if (x > 0) stack.push([x - 1, y]);
            if (x < width - 1) stack.push([x + 1, y]);
            if (y > 0) stack.push([x, y - 1]);
            if (y < height - 1) stack.push([x, y + 1]);
        }
    }
}

/**
 * 選択とホバー
 */
function handleSelect(e) {
    if (isDrawing) return;
    const {x, y} = getGridPos(e);
    if (x >= 0 && x < width && y >= 0 && y < height) {
        const idx = y * width + x;
        const owner = ownerGrid[idx];
        if (owner !== -1) {
            selectedNationId = owner;
            updateNationPanel();
            document.getElementById('nation-panel').style.display = 'block';
        } else {
            document.getElementById('nation-panel').style.display = 'none';
            selectedNationId = -1;
        }
    }
}

function handleHover(e) {
    const hoverInfo = document.getElementById('hover-info');
    if (isDrawing) {
        hoverInfo.style.display = 'none';
        return;
    }
    
    const {x, y} = getGridPos(e);
    if (x >= 0 && x < width && y >= 0 && y < height) {
        const idx = y * width + x;
        const owner = ownerGrid[idx];
        if (owner !== -1) {
            const n = nations.find(nat => nat.id === owner);
            if(n) {
                const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
                const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
                hoverInfo.style.display = 'block';
                hoverInfo.style.left = (clientX + 10) + 'px';
                hoverInfo.style.top = (clientY + 10) + 'px';
                hoverInfo.innerHTML = `<b>${n.name}</b><br>人口: ${formatNum(n.pop)}`;
                return;
            }
        }
    }
    hoverInfo.style.display = 'none';
}

function getGridPos(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
    const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
    
    const relX = clientX - rect.left - canvas.width/2;
    const relY = clientY - rect.top - canvas.height/2;
    const x = Math.floor((relX / mapScale + (width*TILE_SIZE)/2) / TILE_SIZE);
    const y = Math.floor((relY / mapScale + (height*TILE_SIZE)/2) / TILE_SIZE);
    return {x, y};
}

/**
 * ワールド生成ロジック
 */
function generateWorld() {
    isDrawing = false;
    document.getElementById('menu-panel').style.display = 'none';
    document.getElementById('sim-panel').style.display = 'block';

    // 1. 地形補正 (山と川)
    generateTerrainFeatures();

    // 2. 国家生成
    spawnNations();

    log("世界が生成されました。歴史が始まります。", "log-info");
}

function generateTerrainFeatures() {
    // 海岸線からの距離マップを作成
    let distMap = new Array(width * height).fill(0);
    // 簡易的な距離計算 (数回ループさせる)
    for(let i=0; i<3; i++) {
        for(let y=0; y<height; y++) {
            for(let x=0; x<width; x++) {
                let idx = y*width+x;
                if(grid[idx] === 0) { distMap[idx] = 0; continue; }
                
                let minNeighbor = 999;
                // 上下左右を見る
                if(x>0) minNeighbor = Math.min(minNeighbor, distMap[y*width+(x-1)]);
                else minNeighbor = 0;
                if(x<width-1) minNeighbor = Math.min(minNeighbor, distMap[y*width+(x+1)]);
                else minNeighbor = 0;
                if(y>0) minNeighbor = Math.min(minNeighbor, distMap[(y-1)*width+x]);
                else minNeighbor = 0;
                if(y<height-1) minNeighbor = Math.min(minNeighbor, distMap[(y+1)*width+x]);
                else minNeighbor = 0;
                
                distMap[idx] = minNeighbor + 1;
            }
        }
    }

    // 山の生成 (内陸部)
    for(let i=0; i<width*height; i++) {
        if(grid[i] === 1 && distMap[i] > 3) {
            if(Math.random() < 0.3) grid[i] = 2; // Mountain
        }
    }

    // 川の生成 (山から海へ)
    // 簡易的なランダムウォーク
    let rivers = 0;
    for(let i=0; i<width*height; i++) {
        if(grid[i] === 2 && Math.random() < 0.05) { // 山の起点
            let cx = i % width;
            let cy = Math.floor(i / width);
            let path = [];
            let life = 100;
            while(life > 0) {
                path.push(cy*width+cx);
                // 周囲で最も標高(distMap)が低いところへ
                let candidates = [];
                let bestH = distMap[cy*width+cx];
                
                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
                    let nx=cx+dx, ny=cy+dy;
                    if(nx>=0 && nx<width && ny>=0 && ny<height) {
                        let h = distMap[ny*width+nx];
                        if (h < bestH) { candidates = [{x:nx, y:ny, h:h}]; bestH = h; }
                        else if (h === bestH) { candidates.push({x:nx, y:ny, h:h}); }
                    }
                });

                if(candidates.length === 0) break; // 窪地
                let next = candidates[Math.floor(Math.random()*candidates.length)];
                cx = next.x; cy = next.y;
                
                let idx = cy*width+cx;
                if(grid[idx] === 0) break; // 海に到達
                if(grid[idx] !== 2) grid[idx] = 3; // 川にする
                life--;
            }
        }
    }
}

/**
 * 都市クラス
 */
class City {
    constructor(name, tileIdx, nationId) {
        this.name = name;
        this.tileIdx = tileIdx;
        this.nationId = nationId;
        this.unrest = 0;
    }
}

/**
 * 国家クラス
 */
class Nation {
    constructor(id, x, y) {
        this.id = (id !== undefined) ? id : nationIdCounter++;
        this.color = `hsl(${Math.random()*360}, 70%, 50%)`;
        this.baseName = this.generateBaseName();
        this.regimeNumber = 1;
        this.religion = RELIGIONS[Math.floor(Math.random() * RELIGIONS.length)];
        
        // Stats
        this.pop = 1000 + Math.floor(Math.random() * 5000);
        this.gdp = 100 + Math.floor(Math.random() * 900); // 1人あたりではない、国力ベース
        this.industry = 10 + Math.floor(Math.random() * 50);
        this.tech = 0; // Index of TECH_LEVELS
        
        // Politics
        const startGovs = ["絶対王政", "共和制", "帝国", "公国", "連邦制"];
        this.govType = startGovs[Math.floor(Math.random() * startGovs.length)];
        this.updateName();
        this.stability = 100;
        this.unrest = 0;
        this.leader = this.generateLeaderName();
        
        // Military
        this.soldiers = Math.floor(this.pop * 0.1);
        this.soldierQuality = 0.5 + Math.random(); // 0.5 - 1.5
        this.equipQuality = 0.5 + Math.random();
        this.tanks = 0;
        this.ships = 0;
        
        // Diplomacy
        this.relations = {}; // { nationId: value (-100 to 100) }
        this.atWarWith = []; // list of nation IDs
        this.centroid = {x: 0, y: 0};
        this.isDead = false;
        this.isRebel = false;
        this.parentName = "";
        this.rebellionCooldown = 0;
        
        this.cities = [];

        // 初期領土
        if (x !== undefined && y !== undefined) {
            const tileIdx = y * width + x;
            ownerGrid[tileIdx] = this.id;
            this.tiles = [tileIdx];
            // 初期都市（首都）の生成
            this.cities.push(new City(this.baseName + "府", tileIdx, this.id));
        } else {
            this.tiles = [];
        }
    }

    generateBaseName() {
        const syl = ["アル", "バン", "シー", "ドル", "エル", "ファ", "ゴル", "ハン", "イル", "ジョ", "カ", "ロル", "ミ", "ノル", "パ", "ク", "ロ", "サ", "ティ", "ウル", "ヴァ", "キ", "ズ"];
        return syl[Math.floor(Math.random()*syl.length)] + syl[Math.floor(Math.random()*syl.length)];
    }

    generateCityName() {
        const syl = ["アル", "バン", "シー", "ドル", "エル", "ファ", "ゴル", "ハン", "イル", "ジョ", "カ", "ロル", "ミ", "ノル", "パ", "ク", "ロ", "サ", "ティ", "ウル", "ヴァ", "キ", "ズ"];
        const suffix = ["市", "府", "京", "要塞", "港", "都"];
        return syl[Math.floor(Math.random()*syl.length)] + syl[Math.floor(Math.random()*syl.length)] + suffix[Math.floor(Math.random()*suffix.length)];
    }

    updateName() {
        const suffixes = {
            "絶対王政": "王国",
            "共和制": "共和国",
            "帝国": "帝国",
            "公国": "公国",
            "連邦制": "連邦",
            "独裁制": "国",
            "軍事政権": "国",
            "革命政府": "革命政府",
            "臨時政府": "臨時政府",
            "正統政府": "正統政府"
        };
        let suffix = suffixes[this.govType] || "国";
        
        if (this.govType === "共和制" && this.regimeNumber > 1) {
            this.name = this.baseName + suffix + "第" + this.regimeNumber + "政";
        } else {
            this.name = this.baseName + suffix;
        }
    }

    generateLeaderName() {
        const first = ["ヨハン", "フリードリヒ", "ルイ", "チャールズ", "アレクサンダー", "ニコライ", "マリア", "エリザベス", "ヴィクトリア", "カトリーヌ", "スレイマン", "カンヒ", "メイジ", "グスタフ", "カメハメハ"];
        const last = ["世", "大王", "公", "卿", "・ボナパルト", "・ロマノフ", "・ハプスブルク", "・ブルボン", "・テューダー", "・ホーエンツォレルン"];
        if (Math.random() < 0.7) {
            return first[Math.floor(Math.random() * first.length)] + (Math.random() < 0.5 ? last[Math.floor(Math.random() * last.length)] : "");
        } else {
            // 日本風
            const jpFirst = ["織田", "豊臣", "徳川", "武田", "上杉", "毛利", "島津", "伊達"];
            const jpLast = ["信長", "秀吉", "家康", "信玄", "謙信", "元就", "義久", "政宗"];
            return jpFirst[Math.floor(Math.random() * jpFirst.length)] + jpLast[Math.floor(Math.random() * jpLast.length)];
        }
    }

    getMilitaryPower() {
        // 軍事力計算式: 兵数 * 質 * 装備 * (戦車ボーナス)
        let tankBonus = 1 + (this.tanks * 0.05);
        return this.soldiers * this.soldierQuality * this.equipQuality * tankBonus * (1 + this.tech * 0.5);
    }

    getNavalPower() {
        return this.ships * (1 + this.tech * 0.5) * this.equipQuality;
    }

    updateCentroid() {
        if (this.tiles.length > 0) {
            let sumX = 0, sumY = 0;
            for (let i = 0; i < this.tiles.length; i++) {
                const tileIdx = this.tiles[i];
                sumX += tileIdx % width;
                sumY += Math.floor(tileIdx / width);
            }
            this.centroid.x = sumX / this.tiles.length;
            this.centroid.y = sumY / this.tiles.length;
        }
    }

    isCoastal() {
        // 少なくとも1つのタイルが海(0)に接しているか (サンプリング)
        const samples = Math.min(this.tiles.length, 30);
        for(let i=0; i<samples; i++) {
            let tile = this.tiles[Math.floor(Math.random() * this.tiles.length)];
            let cx = tile % width;
            let cy = Math.floor(tile / width);
            let found = false;
            [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
                let nx=cx+dx, ny=cy+dy;
                if(nx>=0 && nx<width && ny>=0 && ny<height) {
                    if(grid[ny*width+nx] === 0) found = true;
                }
            });
            if(found) return true;
        }
        return false;
    }
}

function spawnNations() {
    let landTiles = [];
    for(let i=0; i<grid.length; i++) {
        if(grid[i] === 1) landTiles.push(i);
    }

    // 土地の広さに応じて国家数を決定
    const numNations = Math.max(2, Math.floor(landTiles.length / 50)); 
    nationIdCounter = 0;
    
    for(let i=0; i<numNations; i++) {
        if(landTiles.length === 0) break;
        // ランダムな陸地を選ぶ
        let rndIdx = Math.floor(Math.random() * landTiles.length);
        let tileIdx = landTiles[rndIdx];
        landTiles.splice(rndIdx, 1);
        
        let y = Math.floor(tileIdx / width);
        let x = tileIdx % width;
        
        // 既に誰かの領土ならスキップ（初期配置は離す）
        if(ownerGrid[tileIdx] !== -1) continue;
        
        nations.push(new Nation(undefined, x, y));
    }
    
    // 初期領土拡大 (Flood fill的)
    expandTerritoryInitial();
}

function expandTerritoryInitial() {
    // 簡易的に各国の周囲を埋める
    let changed = true;
    let loopCount = 0;
    while(changed && loopCount < 20) {
        changed = false;
        let newOwners = [...ownerGrid];
        
        // ランダムな順序で処理するためにシャッフル
        let indices = Array.from({length: width*height}, (_, i) => i);
        indices.sort(() => Math.random() - 0.5);

        for(let i of indices) {
            if(grid[i] === 0) continue; // 海は無視
            if(ownerGrid[i] !== -1) continue; // 所有者あり

            // 隣接タイルをチェック
            let neighbors = [];
            let cx = i % width;
            let cy = Math.floor(i / width);
            
            [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
                let nx=cx+dx, ny=cy+dy;
                if(nx>=0 && nx<width && ny>=0 && ny<height) {
                    let nIdx = ny*width+nx;
                    if(ownerGrid[nIdx] !== -1) neighbors.push(ownerGrid[nIdx]);
                }
            });

            if(neighbors.length > 0) {
                // 最も多い隣国に吸収される確率が高い
                let chosen = neighbors[Math.floor(Math.random()*neighbors.length)];
                newOwners[i] = chosen;
                nations[chosen].tiles.push(i);
                changed = true;
            }
        }
        ownerGrid = newOwners;
        loopCount++;
    }

    // 初期重心計算
    nations.forEach(n => n.updateCentroid());
}


/**
 * メインループとシミュレーション
 */
function loop() {
    ctx.fillStyle = "#222";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    renderMap();
    
    if (!isDrawing && !isPaused) {
        frameCounter++;
        if (frameCounter >= (11 - simSpeed)) {
            frameCounter = 0;
            simulateTick();
            year++;
            document.getElementById('info-year').innerText = year;
            document.getElementById('info-tension').innerText = worldTension.toFixed(1) + "%";
            document.getElementById('info-tension').style.color = `rgb(${worldTension*2.55}, ${255 - worldTension*2.55}, 0)`;
        }
    }

    if (selectedNationId !== -1) updateNationPanel();

    animationFrame = requestAnimationFrame(loop);
}

function renderMap() {
    mapScale = Math.min(canvas.width / (width * TILE_SIZE), canvas.height / (height * TILE_SIZE));
    if (mapScale > 1.0) mapScale = 1.0;

    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.scale(mapScale, mapScale);
    ctx.translate(-(width * TILE_SIZE) / 2, -(height * TILE_SIZE) / 2);

    const offsetX = 0;
    const offsetY = 0;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = y * width + x;
            const type = grid[i];
            const owner = ownerGrid[i];
            
            let color = COLORS.WATER;
            if (type === 1) color = COLORS.LAND;
            if (type === 2) color = COLORS.MOUNTAIN;
            if (type === 3) color = COLORS.RIVER;

            // 国の色オーバーレイ
            if (owner !== -1 && !isDrawing) {
                const nat = nations.find(n => n.id === owner);
                if (nat) {
                    // 国の色をベースにするが、地形も見せる (透過させる)
                    ctx.globalAlpha = 0.6;
                    ctx.fillStyle = nat.color;
                    ctx.fillRect(offsetX + x*TILE_SIZE, offsetY + y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    ctx.globalAlpha = 1.0;
                    
                    // 山や川の場合は装飾
                    if (type === 2) { // 山
                        ctx.fillStyle = "rgba(0,0,0,0.5)";
                        ctx.fillRect(offsetX + x*TILE_SIZE+1, offsetY + y*TILE_SIZE+1, TILE_SIZE-2, TILE_SIZE-2);
                    }
                    else if (type === 3) { // 川
                        ctx.fillStyle = "rgba(100,200,255,0.6)";
                        ctx.fillRect(offsetX + x*TILE_SIZE + TILE_SIZE/3, offsetY + y*TILE_SIZE, TILE_SIZE/3, TILE_SIZE);
                    }
                }
            } else {
                // 描画モード or 領土なし
                ctx.fillStyle = color;
                ctx.fillRect(offsetX + x*TILE_SIZE, offsetY + y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }
    }
    
    // 国境線の描画 (HOI4スタイル)
    if (!isDrawing) {
        ctx.lineWidth = 2;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = y * width + x;
                const owner = ownerGrid[i];
                if (owner === -1) continue;

                const rightOwner = (x < width - 1) ? ownerGrid[i + 1] : -2;
                const bottomOwner = (y < height - 1) ? ownerGrid[i + width] : -2;

                if (owner !== rightOwner) {
                    ctx.strokeStyle = "rgba(0,0,0,0.5)";
                    ctx.beginPath();
                    ctx.moveTo(offsetX + (x + 1) * TILE_SIZE, offsetY + y * TILE_SIZE);
                    ctx.lineTo(offsetX + (x + 1) * TILE_SIZE, offsetY + (y + 1) * TILE_SIZE);
                    ctx.stroke();
                }
                if (owner !== bottomOwner) {
                    ctx.strokeStyle = "rgba(0,0,0,0.5)";
                    ctx.beginPath();
                    ctx.moveTo(offsetX + x * TILE_SIZE, offsetY + (y + 1) * TILE_SIZE);
                    ctx.lineTo(offsetX + (x + 1) * TILE_SIZE, offsetY + (y + 1) * TILE_SIZE);
                    ctx.stroke();
                }
            }
        }
    }

    // 都市の描画
    if (!isDrawing) {
        nations.forEach(n => {
            if (n.isDead) return;
            n.cities.forEach(city => {
                const cx = city.tileIdx % width;
                const cy = Math.floor(city.tileIdx / width);
                
                // 都市の影/縁
                ctx.fillStyle = "rgba(0,0,0,0.5)";
                ctx.beginPath();
                ctx.arc(offsetX + cx*TILE_SIZE + TILE_SIZE/2, offsetY + cy*TILE_SIZE + TILE_SIZE/2, TILE_SIZE/2, 0, Math.PI*2);
                ctx.fill();
                
                // 都市本体
                ctx.fillStyle = "#fff";
                ctx.beginPath();
                ctx.arc(offsetX + cx*TILE_SIZE + TILE_SIZE/2, offsetY + cy*TILE_SIZE + TILE_SIZE/2, TILE_SIZE/3, 0, Math.PI*2);
                ctx.fill();
            });
        });

        // 国名の描画 (HOI4スタイル)
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        nations.forEach(n => {
            if (!n.isDead && n.tiles.length > 40) {
                // mapScaleが小さい（ズームアウトしている）ほど、フォントサイズを大きくして視認性を維持
                const baseSize = 12 / mapScale;
                const sizeBonus = Math.min(10 / mapScale, (n.tiles.length / 800) / mapScale);
                const fontSize = baseSize + sizeBonus;
                
                ctx.font = `bold ${fontSize}px "Segoe UI", Roboto, "Helvetica Neue", sans-serif`;

                const drawX = offsetX + n.centroid.x * TILE_SIZE;
                const drawY = offsetY + n.centroid.y * TILE_SIZE;
                
                // 文字の縁取り
                ctx.strokeStyle = "rgba(0,0,0,0.8)";
                ctx.lineWidth = Math.max(2 / mapScale, 2);
                ctx.strokeText(n.name, drawX, drawY);
                
                // 文字本体
                ctx.fillStyle = "rgba(255,255,255,0.9)";
                ctx.fillText(n.name, drawX, drawY);
            }
        });
    }

    // 外枠
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 1;
    ctx.strokeRect(offsetX, offsetY, width*TILE_SIZE, height*TILE_SIZE);
    ctx.restore();
}

function handlePolitics(n) {
    if (n.isDead) return;

    // 指導者の交代
    if (Math.random() < 0.005) {
        const oldLeader = n.leader;
        n.leader = n.generateLeaderName();
        const stabChange = Math.floor(Math.random() * 30) - 20; // -20 to +10
        n.stability = clamp(n.stability + stabChange, 0, 100);
        log(`${n.name}の指導者が${oldLeader}から${n.leader}に交代しました。(安定度: ${stabChange > 0 ? "+" : ""}${stabChange})`, "log-info");
    }

    // 王政国家向けのランダムイベント (共和派の台頭など)
    if ((n.govType === "絶対王政" || n.govType === "帝国") && Math.random() < 0.002) {
        const events = [
            { msg: "共和派の活動が活発化しています。", stab: -15 },
            { msg: "啓蒙思想が広まり、旧体制への不満が高まっています。", stab: -10 },
            { msg: "宮廷内での権力争いが発生しました。", stab: -12 }
        ];
        const event = events[Math.floor(Math.random() * events.length)];
        n.stability = clamp(n.stability + event.stab, 0, 100);
        log(`${n.name}: ${event.msg} (安定度: ${event.stab})`, "log-war");
    }

    // 安定度の自然変動
    if (n.atWarWith.length > 0) {
        n.stability -= 0.4;
    } else {
        n.stability = Math.min(100, n.stability + 0.5);
    }

    // 不満度の更新
    n.unrest = 100 - n.stability;

    // 都市ごとの不満度更新
    n.cities.forEach((city, idx) => {
        let cityUnrest = n.unrest + (Math.random() * 20 - 10);
        // 首都(index 0)からの距離による不満度増加
        if (idx > 0) {
            const capital = n.cities[0];
            const dx = (city.tileIdx % width) - (capital.tileIdx % width);
            const dy = Math.floor(city.tileIdx / width) - Math.floor(capital.tileIdx / width);
            const dist = Math.sqrt(dx*dx + dy*dy);
            cityUnrest += dist / 5;
        }
        city.unrest = clamp(cityUnrest, 0, 100);
    });

    // 反乱クールダウンの消化
    if (n.rebellionCooldown > 0) n.rebellionCooldown--;

    // 都市単位の内戦判定
    let rebellingCities = [];
    if (n.rebellionCooldown === 0 && n.cities.length > 0) {
        n.cities.forEach(city => {
            if (city.unrest > 75 && Math.random() < 0.005) {
                rebellingCities.push(city);
            }
        });
    }

    if (rebellingCities.length > 0) {
        // 周囲の不満が高い都市も誘い込む
        n.cities.forEach(city => {
            if (!rebellingCities.includes(city) && city.unrest > 50) {
                let isNear = rebellingCities.some(rc => {
                    const dx = (city.tileIdx % width) - (rc.tileIdx % width);
                    const dy = Math.floor(city.tileIdx / width) - Math.floor(rc.tileIdx / width);
                    return Math.sqrt(dx*dx + dy*dy) < 30;
                });
                if (isNear && Math.random() < 0.5) rebellingCities.push(city);
            }
        });
        triggerCityRebellion(n, rebellingCities);
    }

    // 政変の判定
    if (n.stability < 50 && Math.random() < 0.002) {
        const oldName = n.name;
        const oldGov = n.govType;
        n.govType = (Math.random() > 0.5) ? "独裁制" : "軍事政権";
        n.updateName();
        n.stability = Math.max(0, n.stability - 30);
        log(`${oldName}で政変が発生！ ${oldGov}から${n.govType}へ体制が変わり、${n.name}となりました。`, "log-war");
    }

    // 共和制への移行
    if (n.govType !== "共和制" && n.tech >= 3 && n.stability > 80 && Math.random() < 0.001) {
        const oldName = n.name;
        n.govType = "共和制";
        n.regimeNumber++;
        n.updateName();
        log(`${oldName}は近代化に伴い共和制へ移行し、${n.name}となりました。`, "log-peace");
    }

    // 反乱軍の正統化
    if (n.isRebel && n.stability > 70 && n.tiles.length > 25 && Math.random() < 0.01) {
        n.isRebel = false;
        const oldName = n.name;
        const newGovs = ["共和制", "帝国", "連邦制"];
        n.govType = newGovs[Math.floor(Math.random() * newGovs.length)];
        n.updateName();
        log(`${oldName}は安定した統治を確立し、${n.name}として国家の正統性を主張し始めました。`, "log-peace");
    }
}

function triggerCityRebellion(n, cities) {
    // 反乱軍の生成
    const rebel = new Nation();
    rebel.baseName = n.baseName;
    rebel.parentName = n.baseName;
    rebel.isRebel = true;

    // かっこいい反乱軍の名称生成
    const rebelTypes = [
        { name: "臨時政府", gov: "臨時政府" },
        { name: "立憲派", gov: "革命政府" },
        { name: "正統政府", gov: "正統政府" },
        { name: "救国戦線", gov: "革命政府" },
        { name: "人民委員会", gov: "革命政府" }
    ];
    
    // 特別な名称: 共和国第n政 (親が共和国の場合)
    if (n.govType === "共和制" && Math.random() < 0.4) {
        rebel.govType = "共和制";
        rebel.regimeNumber = n.regimeNumber + 1;
        rebel.updateName();
    } else {
        const type = rebelTypes[Math.floor(Math.random() * rebelTypes.length)];
        rebel.govType = type.gov;
        // 都市名を冠した名称にする (最初の都市)
        const prefix = cities[0].name.substring(0, cities[0].name.length - 1);
        rebel.name = prefix + type.name;
    }

    rebel.rebellionCooldown = 200; // 初期無敵状態
    n.rebellionCooldown = 200; // 親国も一定期間再発防止
    rebel.color = `hsl(${Math.random()*360}, 80%, 40%)`;
    rebel.tech = n.tech;
    rebel.religion = n.religion;
    
    // 領土と都市の委譲
    cities.forEach(city => {
        const cityIdx = city.tileIdx;
        const cx = cityIdx % width;
        const cy = Math.floor(cityIdx / width);
        const radius = 6;
        
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const nx = cx + dx;
                const ny = cy + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    const idx = ny * width + nx;
                    if (ownerGrid[idx] === n.id) {
                        ownerGrid[idx] = rebel.id;
                        rebel.tiles.push(idx);
                        n.tiles = n.tiles.filter(t => t !== idx);
                    }
                }
            }
        }
        city.nationId = rebel.id;
        rebel.cities.push(city);
    });
    n.cities = n.cities.filter(c => !cities.includes(c));

    // 兵力と人口の分配
    const ratio = cities.length / (n.cities.length + cities.length);
    rebel.pop = Math.floor(n.pop * ratio);
    n.pop = Math.floor(n.pop - rebel.pop);
    rebel.soldiers = Math.floor(n.soldiers * ratio * 0.8);
    n.soldiers = Math.floor(n.soldiers - rebel.soldiers);

    if (rebel.tiles.length > 0) {
        nations.push(rebel);
        declareWar(n, rebel);
        log(`${n.name}で内戦が発生！ ${cities.map(c => c.name).join('、')}が${rebel.name}として蜂起しました。`, "log-war");
        n.stability = Math.max(0, n.stability - 20);
    }
}

function simulateTick() {
    let totalPop = 0;
    // 緊張感の自然減衰
    worldTension = Math.max(0, worldTension - 0.2);

    // 1. 内政フェーズ
    nations.forEach(n => {
        if (n.isDead) return;
        
        handlePolitics(n);

        // 都市の建設
        if (n.tiles.length > (n.cities.length + 1) * 50 && Math.random() < 0.05) {
            const potentialTiles = n.tiles.filter(t => !n.cities.some(c => c.tileIdx === t));
            if (potentialTiles.length > 0) {
                const newTile = potentialTiles[Math.floor(Math.random() * potentialTiles.length)];
                const cityName = n.generateCityName();
                n.cities.push(new City(cityName, newTile, n.id));
                log(`${n.name}が新たな都市「${cityName}」を建設しました。`, "log-info");
            }
        }

        // 人口増加: 領土面積と技術に基づくロジスティック回帰モデル
        let capacity = n.tiles.length * 1000 * (1 + n.tech * 0.5);
        let growth = 0.02 * (1 - n.pop / capacity);
        if (growth < -0.01) growth = -0.01; // 急激な減少を抑える
        n.pop = Math.floor(n.pop * (1 + growth));
        
        // GDP成長: 工業力と人口、技術（人口依存度を下げる）
        n.gdp += (n.industry * 2) + (n.pop * 0.002) * (1 + n.tech);
        
        // 軍備増強: GDPの一部を軍事費へ
        let milBudget = n.gdp * 0.1;
        if (n.atWarWith.length > 0) milBudget = n.gdp * 0.3; // 戦時体制

        // 兵士雇用 / 維持
        let desiredSoldiers = Math.floor(n.pop * 0.05); // 人口の5%が上限目安
        if (n.soldiers < desiredSoldiers && milBudget > 0) {
            n.soldiers += 10;
            milBudget -= 10;
        }
        
        // 技術発展 / 戦車製造
        if (n.gdp > 5000 && n.tech < 4 && Math.random() < 0.01) n.tech++;
        if (n.tech >= 2 && milBudget > 100) {
            n.tanks++;
            milBudget -= 50;
        }
        
        // 海軍建造 (技術レベル2以上かつ海岸線がある場合)
        if (n.tech >= 2 && milBudget > 150 && n.isCoastal()) {
            n.ships++;
            milBudget -= 100;
        }

        // 重心計算
        n.updateCentroid();

        totalPop += n.pop;
    });
    document.getElementById('info-pop').innerText = formatNum(totalPop);

    // 2. 外交フェーズ
    nations.forEach(n => {
        if (n.isDead) return;
        
        // ランダムな対象国を選ぶ (頻度向上)
        const target = nations[Math.floor(Math.random() * nations.length)];
        if (target.id === n.id || target.isDead) return;

        // 関係値初期化
        if (n.relations[target.id] === undefined) n.relations[target.id] = 0;

        // 関係変動要因 (より過激に)
        let change = (Math.random() - 0.5) * 5; 
        if (n.religion === target.religion) change += 5;
        else change -= 5;

        // 世界の緊張感による悪化
        change -= (worldTension / 10);
        
        // 隣接していると摩擦が非常に起きやすい
        let neighbor = isNeighbor(n, target);
        if (neighbor) change -= 10;

        // ボーダーインシデント (突発的な悪化)
        if (neighbor && Math.random() < 0.05) {
            change -= 40;
            log(`偶発的衝突: ${n.name}と${target.name}の間で緊張が高まっています！`, "log-war");
        }

        n.relations[target.id] = clamp(n.relations[target.id] + change, -100, 100);

        // 戦争判定 (閾値を下げ、好戦的に)
        if (n.relations[target.id] < -50 && neighbor) {
            if (!n.atWarWith.includes(target.id)) {
                declareWar(n, target);
            }
        }

        // 野心による開戦 (圧倒的有利な場合)
        if (neighbor && n.getMilitaryPower() > target.getMilitaryPower() * 2 && Math.random() < 0.05) {
            if (!n.atWarWith.includes(target.id)) {
                log(`野心: ${n.name}は${target.name}への領土拡大の好機を見出しました！`, "log-war");
                declareWar(n, target);
            }
        }
        // 和平判定
        else if (n.relations[target.id] > -20 && n.atWarWith.includes(target.id)) {
            makePeace(n, target);
        }
    });

    // 3. 戦争フェーズ
    nations.forEach(attacker => {
        if (attacker.isDead) return;
        
        attacker.atWarWith.forEach(enemyId => {
            const defender = nations.find(n => n.id === enemyId);
            if (!defender || defender.isDead) return;

            // 戦闘処理
            if (isNeighbor(attacker, defender)) {
                battle(attacker, defender);
            } else {
                // 非隣接国への上陸作戦
                if (attacker.tech >= 2 && Math.random() < 0.1) {
                    navalLanding(attacker, defender);
                }
            }
        });
    });
    
    // 滅亡判定
    nations.forEach(n => {
        if (!n.isDead && n.tiles.length === 0) {
            n.isDead = true;
            log(`${n.name}が滅亡しました！`, "log-war");
            // 戦争状態解除
            nations.forEach(other => {
                other.atWarWith = other.atWarWith.filter(id => id !== n.id);
            });
        }
    });
}

function isNeighbor(n1, n2) {
    // 重いので簡易判定: 領土の中心距離などではなく、実際のグリッド走査は重すぎる。
    // ここでは「戦争中なら強制的に接触ありとみなす」または簡易的なランダムチェック
    // 正確にするなら境界線リストを持つべきだが、今回はランダムピックで代用
    for(let i=0; i<50; i++) {
        let tile = n1.tiles[Math.floor(Math.random() * n1.tiles.length)];
        let cx = tile % width;
        let cy = Math.floor(tile / width);
        let found = false;
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
            let nx=cx+dx, ny=cy+dy;
            if(nx>=0 && nx<width && ny>=0 && ny<height) {
                let nIdx = ny*width+nx;
                if(ownerGrid[nIdx] === n2.id) found = true;
            }
        });
        if(found) return true;
    }
    return false;
}

function declareWar(n1, n2) {
    if(n1.atWarWith.includes(n2.id)) return;
    n1.atWarWith.push(n2.id);
    if(!n2.atWarWith.includes(n1.id)) n2.atWarWith.push(n1.id);
    worldTension = Math.min(100, worldTension + 5);
    log(`戦争: ${n1.name}が${n2.name}に宣戦布告しました！（緊張度: ${worldTension.toFixed(1)}%）`, "log-war");
}

function makePeace(n1, n2) {
    n1.atWarWith = n1.atWarWith.filter(id => id !== n2.id);
    n2.atWarWith = n2.atWarWith.filter(id => id !== n1.id);
    log(`和平: ${n1.name}と${n2.name}が停戦合意しました。`, "log-peace");
}

function battle(attacker, defender) {
    // 攻撃側のパワー vs 防御側のパワー + 地形ボーナス
    const atkPow = attacker.getMilitaryPower() * (0.8 + Math.random()*0.4);
    const defPow = defender.getMilitaryPower() * (0.8 + Math.random()*0.4); // 防御有利なしの消耗戦

    // どちらかが領土を奪う
    // 攻撃側が圧倒的に強い場合
    if (atkPow > defPow * 1.5) {
        // 圧倒的勝利: 3タイル奪う
        stealTerritory(attacker, defender);
        stealTerritory(attacker, defender);
        stealTerritory(attacker, defender);
        defender.soldiers = Math.max(0, Math.floor(defender.soldiers * 0.9));
    } else if (atkPow > defPow * 1.1) {
        stealTerritory(attacker, defender);
        // 敗者は兵を失う
        defender.soldiers = Math.max(0, Math.floor(defender.soldiers * 0.95));
    } else {
        // 攻撃失敗、兵を失う
        attacker.soldiers = Math.max(0, Math.floor(attacker.soldiers * 0.98));
    }
}

function navalLanding(attacker, defender) {
    if (!attacker.isCoastal() || !defender.isCoastal()) return;
    if (attacker.ships < 5) return; // ある程度の海軍力が必要

    const atkNaval = attacker.getNavalPower() * (0.8 + Math.random()*0.4);
    const defNaval = defender.getNavalPower() * (0.8 + Math.random()*0.4);

    if (atkNaval > defNaval) {
        // 上陸成功: 敵の海岸タイルを1つ奪う
        stealCoastalTerritory(attacker, defender);
        attacker.ships = Math.max(0, Math.floor(attacker.ships * 0.95)); // 消耗
    } else {
        // 上陸失敗: 海軍力消耗
        attacker.ships = Math.max(0, Math.floor(attacker.ships * 0.8));
    }
}

function stealCoastalTerritory(winner, loser) {
    // 1. 沿岸都市の奪取を優先
    const coastalCities = loser.cities.filter(city => {
        const cx = city.tileIdx % width;
        const cy = Math.floor(city.tileIdx / width);
        let isCoast = false;
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
            let nx=cx+dx, ny=cy+dy;
            if(nx>=0 && nx<width && ny>=0 && ny<height && grid[ny*width+nx] === 0) isCoast = true;
        });
        return isCoast;
    });

    if (coastalCities.length > 0 && Math.random() < 0.5) {
        const targetCity = coastalCities[Math.floor(Math.random() * coastalCities.length)];
        const cx = targetCity.tileIdx % width;
        const cy = Math.floor(targetCity.tileIdx / width);
        const radius = 4;
        
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const nx = cx + dx;
                const ny = cy + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    const idx = ny * width + nx;
                    if (ownerGrid[idx] === loser.id) {
                        ownerGrid[idx] = winner.id;
                        winner.tiles.push(idx);
                        loser.tiles = loser.tiles.filter(t => t !== idx);
                    }
                }
            }
        }
        targetCity.nationId = winner.id;
        winner.cities.push(targetCity);
        loser.cities = loser.cities.filter(c => c !== targetCity);
        loser.stability -= 15;
        log(`海軍作戦: ${winner.name}が${loser.name}の沿岸都市「${targetCity.name}」を占拠しました！`, "log-war");
        return;
    }

    // 2. 失敗した場合は通常の沿岸タイルを奪う
    for(let i=0; i<100; i++) {
        let tile = loser.tiles[Math.floor(Math.random() * loser.tiles.length)];
        let cx = tile % width;
        let cy = Math.floor(tile / width);
        
        let isCoast = false;
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
            let nx=cx+dx, ny=cy+dy;
            if(nx>=0 && nx<width && ny>=0 && ny<height) {
                if(grid[ny*width+nx] === 0) isCoast = true;
            }
        });

        if (isCoast) {
            ownerGrid[tile] = winner.id;
            winner.tiles.push(tile);
            loser.tiles = loser.tiles.filter(t => t !== tile);
            loser.stability -= 5;
            log(`海軍作戦: ${winner.name}が${loser.name}への上陸作戦に成功しました！`, "log-war");
            return;
        }
    }
}

function stealTerritory(winner, loser) {
    // 敗者の領土のうち、勝者と接しているタイルを1つ奪う
    // 計算量削減のため、ランダムサンプリングで境界を探す
    for(let i=0; i<20; i++) {
        let tile = winner.tiles[Math.floor(Math.random() * winner.tiles.length)];
        let cx = tile % width;
        let cy = Math.floor(tile / width);
        
        let targetIdx = -1;
        // 隣接する敗者タイルを探す
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
            let nx=cx+dx, ny=cy+dy;
            if(nx>=0 && nx<width && ny>=0 && ny<height) {
                let idx = ny*width+nx;
                if(ownerGrid[idx] === loser.id) targetIdx = idx;
            }
        });

        if (targetIdx !== -1) {
            // 領土移動処理
            ownerGrid[targetIdx] = winner.id;
            winner.tiles.push(targetIdx);
            loser.tiles = loser.tiles.filter(t => t !== targetIdx);

            loser.stability -= 5;

            // Aggressive Expansion: 他国との関係悪化
            nations.forEach(other => {
                if (other.id !== winner.id && !other.isDead) {
                    if (winner.relations[other.id] !== undefined) {
                        winner.relations[other.id] -= 1; // 小さな蓄積
                    }
                }
            });
            worldTension = Math.min(100, worldTension + 0.1);

            return; // 1ターン1タイルのみ
        }
    }
}

/**
 * UI & Utility
 */
function updateNationPanel() {
    if (selectedNationId === -1) return;
    const n = nations.find(nat => nat.id === selectedNationId);
    if (!n) return;

    document.getElementById('n-name').innerText = n.name + (n.isDead ? " (滅亡)" : "");
    document.getElementById('n-name').style.color = n.color;
    document.getElementById('n-leader').innerText = n.leader;
    document.getElementById('n-gov').innerText = n.govType;
    document.getElementById('n-religion').innerText = n.religion;
    document.getElementById('n-tech').innerText = TECH_LEVELS[n.tech];
    document.getElementById('n-stability').innerText = Math.floor(n.stability) + "%";
    
    document.getElementById('n-gdp').innerText = formatNum(n.gdp);
    document.getElementById('bar-gdp').style.width = Math.min(100, n.gdp / 1000) + "%";
    
    document.getElementById('n-pop').innerText = formatNum(n.pop);
    document.getElementById('bar-pop').style.width = Math.min(100, n.pop / 50000) + "%";
    
    document.getElementById('n-mil').innerText = formatNum(n.soldiers);
    document.getElementById('bar-mil').style.width = Math.min(100, n.soldiers / 5000) + "%";
    
    document.getElementById('n-ind').innerText = n.industry;
    document.getElementById('n-tanks').innerText = n.tanks;
    document.getElementById('n-ships').innerText = n.ships;
    document.getElementById('n-qual').innerText = n.soldierQuality.toFixed(2);
}

function log(msg, className) {
    const logEl = document.getElementById('log');
    const line = document.createElement('div');
    line.innerText = `[Y${year}] ${msg}`;
    if (className) line.className = className;
    logEl.prepend(line);
    if (logEl.children.length > 50) logEl.lastChild.remove();
}

function formatNum(num) {
    if (num >= 100000000) return (num/100000000).toFixed(1) + "億";
    if (num >= 10000) return (num/10000).toFixed(1) + "万";
    return Math.floor(num);
}

function clamp(val, min, max) {
    return Math.min(Math.max(val, min), max);
}

</script>
</body>
</html>
